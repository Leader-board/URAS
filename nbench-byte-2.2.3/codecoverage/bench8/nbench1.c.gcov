        -:    0:Source:nbench1.c
        -:    0:Graph:nbench1.gcno
        -:    0:Data:nbench1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:
        -:    2:/*
        -:    3:** nbench1.c
        -:    4:*/
        -:    5:
        -:    6:/********************************
        -:    7:**       BYTEmark (tm)         **
        -:    8:** BYTE NATIVE MODE BENCHMARKS **
        -:    9:**       VERSION 2             **
        -:   10:**                             **
        -:   11:** Included in this source     **
        -:   12:** file:                       **
        -:   13:**  Numeric Heapsort (around O(n log n), n + n log n assuming that we do it for all elements)          **
        -:   14:**  String Heapsort  (around O(n log n), n + n log n assuming that we do it for all elements)         **
        -:   15:**  Bitfield test    (around O(log n log n) as it appears as we are running a bitmask (that's log n on length) log n times)          **
        -:   16:**  Floating point emulation   **
        -:   17:**  Fourier coefficients // O(n log n) optimally, but this is closer to n^2 as I don't see any sorting      **
        -:   18:**  Assignment algorithm  (O(n) as all I see are random numbers being added)     **
        -:   19:**  IDEA Encyption             **
        -:   20:**  Huffman compression (best = O(n log n))        **
        -:   21:**  Back prop. neural net      **
        -:   22:**  LU Decomposition   (O(mn))        **
        -:   23:**    (linear equations)       **
        -:   24:** ----------                  **
        -:   25:** Rick Grehan, BYTE Magazine  **
        -:   26:*********************************
        -:   27:**
        -:   28:** BYTEmark (tm)
        -:   29:** BYTE's Native Mode Benchmarks
        -:   30:** Rick Grehan, BYTE Magazine
        -:   31:**
        -:   32:** Creation:
        -:   33:** Revision: 3/95;10/95
        -:   34:**  10/95 - Removed allocation that was taking place inside
        -:   35:**   the LU Decomposition benchmark. Though it didn't seem to
        -:   36:**   make a difference on systems we ran it on, it nonetheless
        -:   37:**   removes an operating system dependency that probably should
        -:   38:**   not have been there.
        -:   39:**
        -:   40:** DISCLAIMER
        -:   41:** The source, executable, and documentation files that comprise
        -:   42:** the BYTEmark benchmarks are made available on an "as is" basis.
        -:   43:** This means that we at BYTE Magazine have made every reasonable
        -:   44:** effort to verify that the there are no errors in the source and
        -:   45:** executable code.  We cannot, however, guarantee that the programs
        -:   46:** are error-free.  Consequently, McGraw-HIll and BYTE Magazine make
        -:   47:** no claims in regard to the fitness of the source code, executable
        -:   48:** code, and documentation of the BYTEmark.
        -:   49:**  Furthermore, BYTE Magazine, McGraw-Hill, and all employees
        -:   50:** of McGraw-Hill cannot be held responsible for any damages resulting
        -:   51:** from the use of this code or the results obtained from using
        -:   52:** this code.
        -:   53:*/
        -:   54:
        -:   55:/*
        -:   56:** INCLUDES
        -:   57:*/
        -:   58:#include <stdio.h>
        -:   59:#include <stdlib.h>
        -:   60:#include <string.h>
        -:   61:#include <strings.h>
        -:   62:#include <math.h>
        -:   63:#include <time.h> // for time measurement
        -:   64:#include "nmglobal.h"
        -:   65:#include "nbench1.h"
        -:   66:#include "wordcat.h"
        -:   67:
        -:   68:#ifdef DEBUG
        -:   69:static int numsort_status=0;
        -:   70:static int stringsort_status=0;
        -:   71:#endif
        -:   72:
        -:   73:/*********************
        -:   74:** NUMERIC HEAPSORT **
        -:   75:**********************
        -:   76:** This test implements a heapsort algorithm, performed on an
        -:   77:** array of longs.
        -:   78:*/
        -:   79:
        -:   80:/**************
        -:   81:** DoNumSort **
        -:   82:***************
        -:   83:** This routine performs the CPU numeric sort test.
        -:   84:** NOTE: Last version incorrectly stated that the routine
        -:   85:**  returned result in # of longword sorted per second.
        -:   86:**  Not so; the routine returns # of iterations per sec.
        -:   87:*/
        -:   88:
    #####:   89:void DoNumSort(void)
        -:   90:{
        -:   91:SortStruct *numsortstruct;      /* Local pointer to global struct */
        -:   92:farlong *arraybase;     /* Base pointers of array */
        -:   93:long accumtime;         /* Accumulated time */
        -:   94:double iterations;      /* Iteration counter */
        -:   95:char *errorcontext;     /* Error context string pointer */
        -:   96:int systemerror;        /* For holding error codes */
        -:   97:
        -:   98:/*
        -:   99:** Link to global structure
        -:  100:*/
    #####:  101:numsortstruct=&global_numsortstruct;
        -:  102:
        -:  103:/*
        -:  104:** Set the error context string.
        -:  105:*/
    #####:  106:errorcontext="CPU:Numeric Sort";
        -:  107:
        -:  108:/*
        -:  109:** See if we need to do self adjustment code.
        -:  110:*/
    #####:  111:if(numsortstruct->adjust==0)
        -:  112:{
        -:  113:	/*
        -:  114:	** Self-adjustment code.  The system begins by sorting 1
        -:  115:	** array.  If it does that in no time, then two arrays
        -:  116:	** are built and sorted.  This process continues until
        -:  117:	** enough arrays are built to handle the tolerance.
        -:  118:	*/
    #####:  119:	numsortstruct->numarrays=1;
        -:  120:	while(1)
        -:  121:	{
        -:  122:		/*
        -:  123:		** Allocate space for arrays
        -:  124:		*/
    #####:  125:		arraybase=(farlong *)AllocateMemory(sizeof(long) *
    #####:  126:			numsortstruct->numarrays * numsortstruct->arraysize,
        -:  127:			&systemerror);
    #####:  128:		if(systemerror)
    #####:  129:		{       ReportError(errorcontext,systemerror);
    #####:  130:			FreeMemory((farvoid *)arraybase,
        -:  131:				  &systemerror);
    #####:  132:			ErrorExit();
        -:  133:		}
        -:  134:
        -:  135:		/*
        -:  136:		** Do an iteration of the numeric sort.  If the
        -:  137:		** elapsed time is less than or equal to the permitted
        -:  138:		** minimum, then allocate for more arrays and
        -:  139:		** try again.
        -:  140:		*/
    #####:  141:		if(DoNumSortIteration(arraybase,
        -:  142:			numsortstruct->arraysize,
    #####:  143:			numsortstruct->numarrays)>global_min_ticks)
        -:  144:			break;          /* We're ok...exit */
        -:  145:
    #####:  146:		FreeMemory((farvoid *)arraybase,&systemerror);
    #####:  147:		if(numsortstruct->numarrays++>NUMNUMARRAYS)
    #####:  148:		{       printf("CPU:NSORT -- NUMNUMARRAYS hit.\n");
    #####:  149:			ErrorExit();
        -:  150:		}
        -:  151:	}
        -:  152:}
        -:  153:else
        -:  154:{       /*
        -:  155:	** Allocate space for arrays
        -:  156:	*/
    #####:  157:	arraybase=(farlong *)AllocateMemory(sizeof(long) *
    #####:  158:		numsortstruct->numarrays * numsortstruct->arraysize,
        -:  159:		&systemerror);
    #####:  160:	if(systemerror)
    #####:  161:	{       ReportError(errorcontext,systemerror);
    #####:  162:		FreeMemory((farvoid *)arraybase,
        -:  163:			  &systemerror);
    #####:  164:		ErrorExit();
        -:  165:	}
        -:  166:
        -:  167:}
        -:  168:/*
        -:  169:** All's well if we get here.  Repeatedly perform sorts until the
        -:  170:** accumulated elapsed time is greater than # of seconds requested.
        -:  171:*/
    #####:  172:accumtime=0L;
    #####:  173:iterations=(double)0.0;
        -:  174:
        -:  175:do {
    #####:  176:	accumtime+=DoNumSortIteration(arraybase,
        -:  177:		numsortstruct->arraysize,
    #####:  178:		numsortstruct->numarrays);
    #####:  179:	iterations+=(double)1.0;
    #####:  180:} while(TicksToSecs(accumtime)<numsortstruct->request_secs);
        -:  181:
        -:  182:/*
        -:  183:** Clean up, calculate results, and go home.  Be sure to
        -:  184:** show that we don't have to rerun adjustment code.
        -:  185:*/
    #####:  186:FreeMemory((farvoid *)arraybase,&systemerror);
        -:  187:
    #####:  188:numsortstruct->sortspersec=iterations *
    #####:  189:	(double)numsortstruct->numarrays / TicksToFracSecs(accumtime);
        -:  190:
    #####:  191:if(numsortstruct->adjust==0)
    #####:  192:	numsortstruct->adjust=1;
        -:  193:
        -:  194:#ifdef DEBUG
        -:  195:if (numsort_status==0) printf("Numeric sort: OK\n");
        -:  196:numsort_status=0;
        -:  197:#endif
    #####:  198:return;
        -:  199:}
        -:  200:
        -:  201:/***********************
        -:  202:** DoNumSortIteration **
        -:  203:************************
        -:  204:** This routine executes one iteration of the numeric
        -:  205:** sort benchmark.  It returns the number of ticks
        -:  206:** elapsed for the iteration.
        -:  207:*/
    #####:  208:static ulong DoNumSortIteration(farlong *arraybase,
        -:  209:		ulong arraysize,
        -:  210:		uint numarrays)
        -:  211:{
        -:  212:ulong elapsed;          /* Elapsed ticks */
        -:  213:ulong i;
        -:  214:/*
        -:  215:** Load up the array with random numbers
        -:  216:*/
    #####:  217:LoadNumArrayWithRand(arraybase,arraysize,numarrays);
        -:  218:
        -:  219:/*
        -:  220:** Start the stopwatch
        -:  221:*/
    #####:  222:elapsed=StartStopwatch();
        -:  223:
        -:  224:/*
        -:  225:** Execute a heap of heapsorts
        -:  226:*/
    #####:  227:for(i=0;i<numarrays;i++)
    #####:  228:	NumHeapSort(arraybase+i*arraysize,0L,arraysize-1L);
        -:  229:
        -:  230:/*
        -:  231:** Get elapsed time
        -:  232:*/
    #####:  233:elapsed=StopStopwatch(elapsed);
        -:  234:#ifdef DEBUG
        -:  235:{
        -:  236:	for(i=0;i<arraysize-1;i++)
        -:  237:	{       /*
        -:  238:		** Compare to check for proper
        -:  239:		** sort.
        -:  240:		*/
        -:  241:		if(arraybase[i+1]<arraybase[i])
        -:  242:		{       printf("Sort Error\n");
        -:  243:			numsort_status=1;
        -:  244:                        break;
        -:  245:		}
        -:  246:	}
        -:  247:}
        -:  248:#endif
        -:  249:
    #####:  250:return(elapsed);
        -:  251:}
        -:  252:
        -:  253:/*************************
        -:  254:** LoadNumArrayWithRand **
        -:  255:**************************
        -:  256:** Load up an array with random longs.
        -:  257:*/
    #####:  258:static void LoadNumArrayWithRand(farlong *array,     /* Pointer to arrays */
        -:  259:		ulong arraysize,
        -:  260:		uint numarrays)         /* # of elements in array */
        -:  261:{
        -:  262:long i;                 /* Used for index */
        -:  263:farlong *darray;        /* Destination array pointer */
        -:  264:/*
        -:  265:** Initialize the random number generator
        -:  266:*/
        -:  267:/* randnum(13L); */
    #####:  268:randnum((int32)13);
        -:  269:
        -:  270:/*
        -:  271:** Load up first array with randoms
        -:  272:*/
    #####:  273:for(i=0L;i<arraysize;i++)
        -:  274:        /* array[i]=randnum(0L); */
    #####:  275:	array[i]=randnum((int32)0);
        -:  276:
        -:  277:/*
        -:  278:** Now, if there's more than one array to load, copy the
        -:  279:** first into each of the others.
        -:  280:*/
        -:  281:darray=array;
    #####:  282:while(--numarrays)
    #####:  283:{       darray+=arraysize;
    #####:  284:	for(i=0L;i<arraysize;i++)
    #####:  285:		darray[i]=array[i];
        -:  286:}
        -:  287:
    #####:  288:return;
        -:  289:}
        -:  290:
        -:  291:/****************
        -:  292:** NumHeapSort **
        -:  293:*****************
        -:  294:** Pass this routine a pointer to an array of long
        -:  295:** integers.  Also pass in minimum and maximum offsets.
        -:  296:** This routine performs a heap sort on that array.
        -:  297:*/
    #####:  298:static void NumHeapSort(farlong *array,
        -:  299:	ulong bottom,           /* Lower bound */
        -:  300:	ulong top)              /* Upper bound */
        -:  301:{
        -:  302:ulong temp;                     /* Used to exchange elements */
        -:  303:ulong i;                        /* Loop index */
        -:  304:
        -:  305:/*
        -:  306:** First, build a heap in the array
        -:  307:*/
    #####:  308:for(i=(top/2L); i>0; --i)
    #####:  309:	NumSift(array,i,top);
        -:  310:
        -:  311:/*
        -:  312:** Repeatedly extract maximum from heap and place it at the
        -:  313:** end of the array.  When we get done, we'll have a sorted
        -:  314:** array.
        -:  315:*/
    #####:  316:for(i=top; i>0; --i)
    #####:  317:{       NumSift(array,bottom,i);
    #####:  318:	temp=*array;                    /* Perform exchange */
    #####:  319:	*array=*(array+i);
    #####:  320:	*(array+i)=temp;
        -:  321:}
    #####:  322:return;
        -:  323:}
        -:  324:
        -:  325:/************
        -:  326:** NumSift **
        -:  327:*************
        -:  328:** Peforms the sift operation on a numeric array,
        -:  329:** constructing a heap in the array.
        -:  330:*/
    #####:  331:static void NumSift(farlong *array,     /* Array of numbers */
        -:  332:	ulong i,                /* Minimum of array */
        -:  333:	ulong j)                /* Maximum of array */
        -:  334:{
        -:  335:unsigned long k;
        -:  336:long temp;                              /* Used for exchange */
        -:  337:
    #####:  338:while((i+i)<=j)
        -:  339:{
    #####:  340:	k=i+i;
    #####:  341:	if(k<j)
    #####:  342:		if(array[k]<array[k+1L])
    #####:  343:			++k;
    #####:  344:	if(array[i]<array[k])
        -:  345:	{
    #####:  346:		temp=array[k];
    #####:  347:		array[k]=array[i];
    #####:  348:		array[i]=temp;
    #####:  349:		i=k;
        -:  350:	}
        -:  351:	else
    #####:  352:		i=j+1;
        -:  353:}
    #####:  354:return;
        -:  355:}
        -:  356:
        -:  357:/********************
        -:  358:** STRING HEAPSORT **
        -:  359:********************/
        -:  360:
        -:  361:/*****************
        -:  362:** DoStringSort **
        -:  363:******************
        -:  364:** This routine performs the CPU string sort test.
        -:  365:** Arguments:
        -:  366:**      requested_secs = # of seconds to execute test
        -:  367:**      stringspersec = # of strings per second sorted (RETURNED)
        -:  368:*/
    #####:  369:void DoStringSort(void)
        -:  370:{
        -:  371:
        -:  372:SortStruct *strsortstruct;      /* Local for sort structure */
        -:  373:faruchar *arraybase;            /* Base pointer of char array */
        -:  374:long accumtime;                 /* Accumulated time */
        -:  375:double iterations;              /* # of iterations */
        -:  376:char *errorcontext;             /* Error context string pointer */
        -:  377:int systemerror;                /* For holding error code */
        -:  378:
        -:  379:/*
        -:  380:** Link to global structure
        -:  381:*/
    #####:  382:strsortstruct=&global_strsortstruct;
        -:  383:
        -:  384:/*
        -:  385:** Set the error context
        -:  386:*/
    #####:  387:errorcontext="CPU:String Sort";
        -:  388:
        -:  389:/*
        -:  390:** See if we have to perform self-adjustment code
        -:  391:*/
    #####:  392:if(strsortstruct->adjust==0)
        -:  393:{
        -:  394:	/*
        -:  395:	** Initialize the number of arrays.
        -:  396:	*/
    #####:  397:	strsortstruct->numarrays=1;
        -:  398:	while(1)
        -:  399:	{
        -:  400:		/*
        -:  401:		** Allocate space for array.  We'll add an extra 100
        -:  402:		** bytes to protect memory as strings move around
        -:  403:		** (this can happen during string adjustment)
        -:  404:		*/
    #####:  405:		arraybase=(faruchar *)AllocateMemory((strsortstruct->arraysize+100L) *
    #####:  406:			(long)strsortstruct->numarrays,&systemerror);
    #####:  407:		if(systemerror)
    #####:  408:		{       ReportError(errorcontext,systemerror);
    #####:  409:			ErrorExit();
        -:  410:		}
        -:  411:
        -:  412:		/*
        -:  413:		** Do an iteration of the string sort.  If the
        -:  414:		** elapsed time is less than or equal to the permitted
        -:  415:		** minimum, then de-allocate the array, reallocate a
        -:  416:		** an additional array, and try again.
        -:  417:		*/
    #####:  418:		if(DoStringSortIteration(arraybase,
    #####:  419:			strsortstruct->numarrays,
    #####:  420:			strsortstruct->arraysize)>global_min_ticks)
        -:  421:			break;          /* We're ok...exit */
        -:  422:
    #####:  423:		FreeMemory((farvoid *)arraybase,&systemerror);
    #####:  424:		strsortstruct->numarrays+=1;
        -:  425:	}
        -:  426:}
        -:  427:else
        -:  428:{
        -:  429:	/*
        -:  430:	** We don't have to perform self adjustment code.
        -:  431:	** Simply allocate the space for the array.
        -:  432:	*/
    #####:  433:	arraybase=(faruchar *)AllocateMemory((strsortstruct->arraysize+100L) *
    #####:  434:		(long)strsortstruct->numarrays,&systemerror);
    #####:  435:	if(systemerror)
    #####:  436:	{       ReportError(errorcontext,systemerror);
    #####:  437:		ErrorExit();
        -:  438:	}
        -:  439:}
        -:  440:/*
        -:  441:** All's well if we get here.  Repeatedly perform sorts until the
        -:  442:** accumulated elapsed time is greater than # of seconds requested.
        -:  443:*/
    #####:  444:accumtime=0L;
    #####:  445:iterations=(double)0.0;
        -:  446:
        -:  447:do {
    #####:  448:	accumtime+=DoStringSortIteration(arraybase,
    #####:  449:				strsortstruct->numarrays,
        -:  450:				strsortstruct->arraysize);
    #####:  451:	iterations+=(double)strsortstruct->numarrays;
    #####:  452:} while(TicksToSecs(accumtime)<strsortstruct->request_secs);
        -:  453:
        -:  454:/*
        -:  455:** Clean up, calculate results, and go home.
        -:  456:** Set flag to show we don't need to rerun adjustment code.
        -:  457:*/
    #####:  458:FreeMemory((farvoid *)arraybase,&systemerror);
    #####:  459:strsortstruct->sortspersec=iterations / (double)TicksToFracSecs(accumtime);
    #####:  460:if(strsortstruct->adjust==0)
    #####:  461:	strsortstruct->adjust=1;
        -:  462:#ifdef DEBUG
        -:  463:if (stringsort_status==0) printf("String sort: OK\n");
        -:  464:stringsort_status=0;
        -:  465:#endif
    #####:  466:return;
        -:  467:}
        -:  468:
        -:  469:/**************************
        -:  470:** DoStringSortIteration **
        -:  471:***************************
        -:  472:** This routine executes one iteration of the string
        -:  473:** sort benchmark.  It returns the number of ticks
        -:  474:** Note that this routine also builds the offset pointer
        -:  475:** array.
        -:  476:*/
    #####:  477:static ulong DoStringSortIteration(faruchar *arraybase,
        -:  478:		uint numarrays,ulong arraysize)
        -:  479:{
        -:  480:farulong *optrarray;            /* Offset pointer array */
        -:  481:unsigned long elapsed;          /* Elapsed ticks */
        -:  482:unsigned long nstrings;         /* # of strings in array */
        -:  483:int syserror;                   /* System error code */
        -:  484:unsigned int i;                 /* Index */
        -:  485:farulong *tempobase;            /* Temporary offset pointer base */
        -:  486:faruchar *tempsbase;            /* Temporary string base pointer */
        -:  487:
        -:  488:/*
        -:  489:** Load up the array(s) with random numbers
        -:  490:*/
    #####:  491:optrarray=LoadStringArray(arraybase,numarrays,&nstrings,arraysize);
        -:  492:
        -:  493:/*
        -:  494:** Set temp base pointers...they will be modified as the
        -:  495:** benchmark proceeds.
        -:  496:*/
    #####:  497:tempobase=optrarray;
    #####:  498:tempsbase=arraybase;
        -:  499:
        -:  500:/*
        -:  501:** Start the stopwatch
        -:  502:*/
    #####:  503:elapsed=StartStopwatch();
        -:  504:
        -:  505:/*
        -:  506:** Execute heapsorts
        -:  507:*/
    #####:  508:for(i=0;i<numarrays;i++)
    #####:  509:{       StrHeapSort(tempobase,tempsbase,nstrings,0L,nstrings-1);
    #####:  510:	tempobase+=nstrings;    /* Advance base pointers */
    #####:  511:	tempsbase+=arraysize+100;
        -:  512:}
        -:  513:
        -:  514:/*
        -:  515:** Record elapsed time
        -:  516:*/
    #####:  517:elapsed=StopStopwatch(elapsed);
        -:  518:
        -:  519:#ifdef DEBUG
        -:  520:{
        -:  521:	unsigned long i;
        -:  522:	for(i=0;i<nstrings-1;i++)
        -:  523:	{       /*
        -:  524:		** Compare strings to check for proper
        -:  525:		** sort.
        -:  526:		*/
        -:  527:		if(str_is_less(optrarray,arraybase,nstrings,i+1,i))
        -:  528:		{       printf("Sort Error\n");
        -:  529:			stringsort_status=1;
        -:  530:                        break;
        -:  531:		}
        -:  532:	}
        -:  533:}
        -:  534:#endif
        -:  535:
        -:  536:/*
        -:  537:** Release the offset pointer array built by
        -:  538:** LoadStringArray()
        -:  539:*/
    #####:  540:FreeMemory((farvoid *)optrarray,&syserror);
        -:  541:
        -:  542:/*
        -:  543:** Return elapsed ticks.
        -:  544:*/
    #####:  545:return(elapsed);
        -:  546:}
        -:  547:
        -:  548:/********************
        -:  549:** LoadStringArray **
        -:  550:*********************
        -:  551:** Initialize the string array with random strings of
        -:  552:** varying sizes.
        -:  553:** Returns the pointer to the offset pointer array.
        -:  554:** Note that since we're creating a number of arrays, this
        -:  555:** routine builds one array, then copies it into the others.
        -:  556:*/
    #####:  557:static farulong *LoadStringArray(faruchar *strarray, /* String array */
        -:  558:	uint numarrays,                 /* # of arrays */
        -:  559:	ulong *nstrings,                /* # of strings */
        -:  560:	ulong arraysize)                /* Size of array */
        -:  561:{
        -:  562:faruchar *tempsbase;            /* Temporary string base pointer */
        -:  563:farulong *optrarray;            /* Local for pointer */
        -:  564:farulong *tempobase;            /* Temporary offset pointer base pointer */
        -:  565:unsigned long curroffset;       /* Current offset */
        -:  566:int fullflag;                   /* Indicates full array */
        -:  567:unsigned char stringlength;     /* Length of string */
        -:  568:unsigned char i;                /* Index */
        -:  569:unsigned long j;                /* Another index */
        -:  570:unsigned int k;                 /* Yet another index */
        -:  571:unsigned int l;                 /* Ans still one more index */
        -:  572:int systemerror;                /* For holding error code */
        -:  573:
        -:  574:/*
        -:  575:** Initialize random number generator.
        -:  576:*/
        -:  577:/* randnum(13L); */
    #####:  578:randnum((int32)13);
        -:  579:
        -:  580:/*
        -:  581:** Start with no strings.  Initialize our current offset pointer
        -:  582:** to 0.
        -:  583:*/
    #####:  584:*nstrings=0L;
    #####:  585:curroffset=0L;
    #####:  586:fullflag=0;
        -:  587:
        -:  588:do
        -:  589:{
        -:  590:	/*
        -:  591:	** Allocate a string with a random length no
        -:  592:	** shorter than 4 bytes and no longer than
        -:  593:	** 80 bytes.  Note we have to also make sure
        -:  594:	** there's room in the array.
        -:  595:	*/
        -:  596:        /* stringlength=(unsigned char)((1+abs_randwc(76L)) & 0xFFL);*/
    #####:  597:	stringlength=(unsigned char)((1+abs_randwc((int32)76)) & 0xFFL);
    #####:  598:	if((unsigned long)stringlength+curroffset+1L>=arraysize)
    #####:  599:	{       stringlength=(unsigned char)((arraysize-curroffset-1L) &
        -:  600:				0xFF);
    #####:  601:		fullflag=1;     /* Indicates a full */
        -:  602:	}
        -:  603:
        -:  604:	/*
        -:  605:	** Store length at curroffset and advance current offset.
        -:  606:	*/
    #####:  607:	*(strarray+curroffset)=stringlength;
    #####:  608:	curroffset++;
        -:  609:
        -:  610:	/*
        -:  611:	** Fill up the rest of the string with random bytes.
        -:  612:	*/
    #####:  613:	for(i=0;i<stringlength;i++)
    #####:  614:	{       *(strarray+curroffset)=
        -:  615:		        /* (unsigned char)(abs_randwc((long)0xFE)); */
    #####:  616:			(unsigned char)(abs_randwc((int32)0xFE));
    #####:  617:		curroffset++;
        -:  618:	}
        -:  619:
        -:  620:	/*
        -:  621:	** Increment the # of strings counter.
        -:  622:	*/
    #####:  623:	*nstrings+=1L;
        -:  624:
    #####:  625:} while(fullflag==0);
        -:  626:
        -:  627:/*
        -:  628:** We now have initialized a single full array.  If there
        -:  629:** is more than one array, copy the original into the
        -:  630:** others.
        -:  631:*/
        -:  632:k=1;
        -:  633:tempsbase=strarray;
    #####:  634:while(k<numarrays)
    #####:  635:{       tempsbase+=arraysize+100;         /* Set base */
    #####:  636:	for(l=0;l<arraysize;l++)
    #####:  637:		tempsbase[l]=strarray[l];
    #####:  638:	k++;
        -:  639:}
        -:  640:
        -:  641:/*
        -:  642:** Now the array is full, allocate enough space for an
        -:  643:** offset pointer array.
        -:  644:*/
    #####:  645:optrarray=(farulong *)AllocateMemory(*nstrings * sizeof(unsigned long) *
        -:  646:		numarrays,
        -:  647:		&systemerror);
    #####:  648:if(systemerror)
    #####:  649:{       ReportError("CPU:Stringsort",systemerror);
    #####:  650:	FreeMemory((void *)strarray,&systemerror);
    #####:  651:	ErrorExit();
        -:  652:}
        -:  653:
        -:  654:/*
        -:  655:** Go through the newly-built string array, building
        -:  656:** offsets and putting them into the offset pointer
        -:  657:** array.
        -:  658:*/
        -:  659:curroffset=0;
    #####:  660:for(j=0;j<*nstrings;j++)
    #####:  661:{       *(optrarray+j)=curroffset;
    #####:  662:	curroffset+=(unsigned long)(*(strarray+curroffset))+1L;
        -:  663:}
        -:  664:
        -:  665:/*
        -:  666:** As above, we've made one copy of the offset pointers,
        -:  667:** so duplicate this array in the remaining ones.
        -:  668:*/
        -:  669:k=1;
        -:  670:tempobase=optrarray;
    #####:  671:while(k<numarrays)
    #####:  672:{       tempobase+=*nstrings;
    #####:  673:	for(l=0;l<*nstrings;l++)
    #####:  674:		tempobase[l]=optrarray[l];
    #####:  675:	k++;
        -:  676:}
        -:  677:
        -:  678:/*
        -:  679:** All done...go home.  Pass local pointer back.
        -:  680:*/
    #####:  681:return(optrarray);
        -:  682:}
        -:  683:
        -:  684:/**************
        -:  685:** stradjust **
        -:  686:***************
        -:  687:** Used by the string heap sort.  Call this routine to adjust the
        -:  688:** string at offset i to length l.  The members of the string array
        -:  689:** are moved accordingly and the length of the string at offset i
        -:  690:** is set to l.
        -:  691:*/
    #####:  692:static void stradjust(farulong *optrarray,      /* Offset pointer array */
        -:  693:	faruchar *strarray,                     /* String array */
        -:  694:	ulong nstrings,                         /* # of strings */
        -:  695:	ulong i,                                /* Offset to adjust */
        -:  696:	uchar l)                                /* New length */
        -:  697:{
        -:  698:unsigned long nbytes;           /* # of bytes to move */
        -:  699:unsigned long j;                /* Index */
        -:  700:int direction;                  /* Direction indicator */
        -:  701:unsigned char adjamount;        /* Adjustment amount */
        -:  702:
        -:  703:/*
        -:  704:** If new length is less than old length, the direction is
        -:  705:** down.  If new length is greater than old length, the
        -:  706:** direction is up.
        -:  707:*/
    #####:  708:direction=(int)l - (int)*(strarray+*(optrarray+i));
    #####:  709:adjamount=(unsigned char)abs(direction);
        -:  710:
        -:  711:/*
        -:  712:** See if the adjustment is being made to the last
        -:  713:** string in the string array.  If so, we don't have to
        -:  714:** do anything more than adjust the length field.
        -:  715:*/
    #####:  716:if(i==(nstrings-1L))
    #####:  717:{       *(strarray+*(optrarray+i))=l;
    #####:  718:	return;
        -:  719:}
        -:  720:
        -:  721:/*
        -:  722:** Calculate the total # of bytes in string array from
        -:  723:** location i+1 to end of array.  Whether we're moving "up" or
        -:  724:** down, this is how many bytes we'll have to move.
        -:  725:*/
    #####:  726:nbytes=*(optrarray+nstrings-1L) +
    #####:  727:	(unsigned long)*(strarray+*(optrarray+nstrings-1L)) + 1L -
    #####:  728:	*(optrarray+i+1L);
        -:  729:
        -:  730:/*
        -:  731:** Calculate the source and the destination.  Source is
        -:  732:** string position i+1.  Destination is string position i+l
        -:  733:** (i+"ell"...don't confuse 1 and l).
        -:  734:** Hand this straight to memmove and let it handle the
        -:  735:** "overlap" problem.
        -:  736:*/
    #####:  737:MoveMemory((farvoid *)(strarray+*(optrarray+i)+l+1),
    #####:  738:	(farvoid *)(strarray+*(optrarray+i+1)),
        -:  739:	(unsigned long)nbytes);
        -:  740:
        -:  741:/*
        -:  742:** We have to adjust the offset pointer array.
        -:  743:** This covers string i+1 to numstrings-1.
        -:  744:*/
    #####:  745:for(j=i+1;j<nstrings;j++)
    #####:  746:	if(direction<0)
    #####:  747:		*(optrarray+j)=*(optrarray+j)-adjamount;
        -:  748:	else
    #####:  749:		*(optrarray+j)=*(optrarray+j)+adjamount;
        -:  750:
        -:  751:/*
        -:  752:** Store the new length and go home.
        -:  753:*/
    #####:  754:*(strarray+*(optrarray+i))=l;
    #####:  755:return;
        -:  756:}
        -:  757:
        -:  758:/****************
        -:  759:** strheapsort **
        -:  760:*****************
        -:  761:** Pass this routine a pointer to an array of unsigned char.
        -:  762:** The array is presumed to hold strings occupying at most
        -:  763:** 80 bytes (counts a byte count).
        -:  764:** This routine also needs a pointer to an array of offsets
        -:  765:** which represent string locations in the array, and
        -:  766:** an unsigned long indicating the number of strings
        -:  767:** in the array.
        -:  768:*/
    #####:  769:static void StrHeapSort(farulong *optrarray, /* Offset pointers */
        -:  770:	faruchar *strarray,             /* Strings array */
        -:  771:	ulong numstrings,               /* # of strings in array */
        -:  772:	ulong bottom,                   /* Region to sort...bottom */
        -:  773:	ulong top)                      /* Region to sort...top */
        -:  774:{
        -:  775:unsigned char temp[80];                 /* Used to exchange elements */
        -:  776:unsigned char tlen;                     /* Temp to hold length */
        -:  777:unsigned long i;                        /* Loop index */
        -:  778:
        -:  779:
        -:  780:/*
        -:  781:** Build a heap in the array
        -:  782:*/
    #####:  783:for(i=(top/2L); i>0; --i)
    #####:  784:	strsift(optrarray,strarray,numstrings,i,top);
        -:  785:
        -:  786:/*
        -:  787:** Repeatedly extract maximum from heap and place it at the
        -:  788:** end of the array.  When we get done, we'll have a sorted
        -:  789:** array.
        -:  790:*/
    #####:  791:for(i=top; i>0; --i)
        -:  792:{
    #####:  793:	strsift(optrarray,strarray,numstrings,0,i);
        -:  794:
        -:  795:	/* temp = string[0] */
    #####:  796:	tlen=*strarray;
    #####:  797:	MoveMemory((farvoid *)&temp[0], /* Perform exchange */
        -:  798:		(farvoid *)strarray,
    #####:  799:		(unsigned long)(tlen+1));
        -:  800:
        -:  801:
        -:  802:	/* string[0]=string[i] */
    #####:  803:	tlen=*(strarray+*(optrarray+i));
    #####:  804:	stradjust(optrarray,strarray,numstrings,0,tlen);
    #####:  805:	MoveMemory((farvoid *)strarray,
    #####:  806:		(farvoid *)(strarray+*(optrarray+i)),
    #####:  807:		(unsigned long)(tlen+1));
        -:  808:
        -:  809:	/* string[i]=temp */
    #####:  810:	tlen=temp[0];
    #####:  811:	stradjust(optrarray,strarray,numstrings,i,tlen);
    #####:  812:	MoveMemory((farvoid *)(strarray+*(optrarray+i)),
        -:  813:		(farvoid *)&temp[0],
    #####:  814:		(unsigned long)(tlen+1));
        -:  815:
        -:  816:}
    #####:  817:return;
        -:  818:}
        -:  819:
        -:  820:/****************
        -:  821:** str_is_less **
        -:  822:*****************
        -:  823:** Pass this function:
        -:  824:**      1) A pointer to an array of offset pointers
        -:  825:**      2) A pointer to a string array
        -:  826:**      3) The number of elements in the string array
        -:  827:**      4) Offsets to two strings (a & b)
        -:  828:** This function returns TRUE if string a is < string b.
        -:  829:*/
    #####:  830:static int str_is_less(farulong *optrarray, /* Offset pointers */
        -:  831:	faruchar *strarray,                     /* String array */
        -:  832:	ulong numstrings,                       /* # of strings */
        -:  833:	ulong a, ulong b)                       /* Offsets */
        -:  834:{
        -:  835:int slen;               /* String length */
        -:  836:
        -:  837:/*
        -:  838:** Determine which string has the minimum length.  Use that
        -:  839:** to call strncmp().  If they match up to that point, the
        -:  840:** string with the longer length wins.
        -:  841:*/
    #####:  842:slen=(int)*(strarray+*(optrarray+a));
    #####:  843:if(slen > (int)*(strarray+*(optrarray+b)))
    #####:  844:	slen=(int)*(strarray+*(optrarray+b));
        -:  845:
    #####:  846:slen=strncmp((char *)(strarray+*(optrarray+a)),
        -:  847:		(char *)(strarray+*(optrarray+b)),slen);
        -:  848:
    #####:  849:if(slen==0)
        -:  850:{
        -:  851:	/*
        -:  852:	** They match.  Return true if the length of a
        -:  853:	** is greater than the length of b.
        -:  854:	*/
    #####:  855:	if(*(strarray+*(optrarray+a)) >
        -:  856:		*(strarray+*(optrarray+b)))
        -:  857:		return(TRUE);
        -:  858:	return(FALSE);
        -:  859:}
        -:  860:
    #####:  861:if(slen<0) return(TRUE);        /* a is strictly less than b */
        -:  862:
        -:  863:return(FALSE);                  /* Only other possibility */
        -:  864:}
        -:  865:
        -:  866:/************
        -:  867:** strsift **
        -:  868:*************
        -:  869:** Pass this function:
        -:  870:**      1) A pointer to an array of offset pointers
        -:  871:**      2) A pointer to a string array
        -:  872:**      3) The number of elements in the string array
        -:  873:**      4) Offset within which to sort.
        -:  874:** Sift the array within the bounds of those offsets (thus
        -:  875:** building a heap).
        -:  876:*/
    #####:  877:static void strsift(farulong *optrarray,        /* Offset pointers */
        -:  878:	faruchar *strarray,                     /* String array */
        -:  879:	ulong numstrings,                       /* # of strings */
        -:  880:	ulong i, ulong j)                       /* Offsets */
        -:  881:{
        -:  882:unsigned long k;                /* Temporaries */
        -:  883:unsigned char temp[80];
        -:  884:unsigned char tlen;             /* For string lengths */
        -:  885:
        -:  886:
    #####:  887:while((i+i)<=j)
        -:  888:{
    #####:  889:	k=i+i;
    #####:  890:	if(k<j)
    #####:  891:		if(str_is_less(optrarray,strarray,numstrings,k,k+1L))
    #####:  892:			++k;
    #####:  893:	if(str_is_less(optrarray,strarray,numstrings,i,k))
        -:  894:	{
        -:  895:		/* temp=string[k] */
    #####:  896:		tlen=*(strarray+*(optrarray+k));
    #####:  897:		MoveMemory((farvoid *)&temp[0],
        -:  898:			(farvoid *)(strarray+*(optrarray+k)),
    #####:  899:			(unsigned long)(tlen+1));
        -:  900:
        -:  901:		/* string[k]=string[i] */
    #####:  902:		tlen=*(strarray+*(optrarray+i));
    #####:  903:		stradjust(optrarray,strarray,numstrings,k,tlen);
    #####:  904:		MoveMemory((farvoid *)(strarray+*(optrarray+k)),
    #####:  905:			(farvoid *)(strarray+*(optrarray+i)),
    #####:  906:			(unsigned long)(tlen+1));
        -:  907:
        -:  908:		/* string[i]=temp */
    #####:  909:		tlen=temp[0];
    #####:  910:		stradjust(optrarray,strarray,numstrings,i,tlen);
    #####:  911:		MoveMemory((farvoid *)(strarray+*(optrarray+i)),
        -:  912:			(farvoid *)&temp[0],
    #####:  913:			(unsigned long)(tlen+1));
    #####:  914:		i=k;
        -:  915:	}
        -:  916:	else
    #####:  917:		i=j+1;
        -:  918:}
    #####:  919:return;
        -:  920:}
        -:  921:
        -:  922:/************************
        -:  923:** BITFIELD OPERATIONS **
        -:  924:*************************/
        -:  925:
        -:  926:/*************
        -:  927:** DoBitops **
        -:  928:**************
        -:  929:** Perform the bit operations test portion of the CPU
        -:  930:** benchmark.  Returns the iterations per second.
        -:  931:*/
    #####:  932:void DoBitops(void)
        -:  933:{
        -:  934:BitOpStruct *locbitopstruct;    /* Local bitop structure */
        -:  935:farulong *bitarraybase;         /* Base of bitmap array */
        -:  936:farulong *bitoparraybase;       /* Base of bitmap operations array */
        -:  937:ulong nbitops;                  /* # of bitfield operations */
        -:  938:ulong accumtime;                /* Accumulated time in ticks */
        -:  939:double iterations;              /* # of iterations */
        -:  940:char *errorcontext;             /* Error context string */
        -:  941:int systemerror;                /* For holding error codes */
        -:  942:int ticks;
        -:  943:
        -:  944:/*
        -:  945:** Link to global structure.
        -:  946:*/
    #####:  947:locbitopstruct=&global_bitopstruct;
        -:  948:
        -:  949:/*
        -:  950:** Set the error context.
        -:  951:*/
    #####:  952:errorcontext="CPU:Bitfields";
        -:  953:
        -:  954:/*
        -:  955:** See if we need to run adjustment code.
        -:  956:*/
    #####:  957:if(locbitopstruct->adjust==0)
        -:  958:{
    #####:  959:	bitarraybase=(farulong *)AllocateMemory(locbitopstruct->bitfieldarraysize *
        -:  960:		sizeof(ulong),&systemerror);
    #####:  961:	if(systemerror)
    #####:  962:	{       ReportError(errorcontext,systemerror);
    #####:  963:		ErrorExit();
        -:  964:	}
        -:  965:
        -:  966:	/*
        -:  967:	** Initialize bitfield operations array to [2,30] elements
        -:  968:	*/
    #####:  969:	locbitopstruct->bitoparraysize=30L;
        -:  970:
        -:  971:	while(1)
        -:  972:	{
        -:  973:		/*
        -:  974:		** Allocate space for operations array
        -:  975:		*/
    #####:  976:		bitoparraybase=(farulong *)AllocateMemory(locbitopstruct->bitoparraysize*2L*
        -:  977:			sizeof(ulong),
        -:  978:			&systemerror);
    #####:  979:		if(systemerror)
    #####:  980:		{       ReportError(errorcontext,systemerror);
    #####:  981:			FreeMemory((farvoid *)bitarraybase,&systemerror);
    #####:  982:			ErrorExit();
        -:  983:		}
        -:  984:		/*
        -:  985:		** Do an iteration of the bitmap test.  If the
        -:  986:		** elapsed time is less than or equal to the permitted
        -:  987:		** minimum, then de-allocate the array, reallocate a
        -:  988:		** larger version, and try again.
        -:  989:		*/
    #####:  990:		ticks=DoBitfieldIteration(bitarraybase,
        -:  991:					   bitoparraybase,
    #####:  992:					   locbitopstruct->bitoparraysize,
        -:  993:					   &nbitops);
        -:  994:#ifdef DEBUG
        -:  995:#ifdef LINUX
        -:  996:	        if (locbitopstruct->bitoparraysize==30L){
        -:  997:		  /* this is the first loop, write a debug file */
        -:  998:		  FILE *file;
        -:  999:		  unsigned long *running_base; /* same as farulong */
        -: 1000:		  long counter;
        -: 1001:		  file=fopen("debugbit.dat","w");
        -: 1002:		  running_base=bitarraybase;
        -: 1003:		  for (counter=0;counter<(long)(locbitopstruct->bitfieldarraysize);counter++){
        -: 1004:#ifdef LONG64
        -: 1005:		    fprintf(file,"%08X",(unsigned int)(*running_base&0xFFFFFFFFL));
        -: 1006:		    fprintf(file,"%08X",(unsigned int)((*running_base>>32)&0xFFFFFFFFL));
        -: 1007:		    if ((counter+1)%4==0) fprintf(file,"\n");
        -: 1008:#else
        -: 1009:		    fprintf(file,"%08lX",*running_base);
        -: 1010:		    if ((counter+1)%8==0) fprintf(file,"\n");
        -: 1011:#endif
        -: 1012:		    running_base=running_base+1;
        -: 1013:		  }
        -: 1014:		  fclose(file);
        -: 1015:		  printf("\nWrote the file debugbit.dat, you may want to compare it to debugbit.good\n");
        -: 1016:		}
        -: 1017:#endif
        -: 1018:#endif
        -: 1019:
    #####: 1020:		if (ticks>global_min_ticks) break;      /* We're ok...exit */
        -: 1021:
    #####: 1022:		FreeMemory((farvoid *)bitoparraybase,&systemerror);
    #####: 1023:		locbitopstruct->bitoparraysize+=100L;
        -: 1024:	}
        -: 1025:}
        -: 1026:else
        -: 1027:{
        -: 1028:	/*
        -: 1029:	** Don't need to do self adjustment, just allocate
        -: 1030:	** the array space.
        -: 1031:	*/
    #####: 1032:	bitarraybase=(farulong *)AllocateMemory(locbitopstruct->bitfieldarraysize *
        -: 1033:		sizeof(ulong),&systemerror);
    #####: 1034:	if(systemerror)
    #####: 1035:	{       ReportError(errorcontext,systemerror);
    #####: 1036:		ErrorExit();
        -: 1037:	}
    #####: 1038:	bitoparraybase=(farulong *)AllocateMemory(locbitopstruct->bitoparraysize*2L*
        -: 1039:		sizeof(ulong),
        -: 1040:		&systemerror);
    #####: 1041:	if(systemerror)
    #####: 1042:	{       ReportError(errorcontext,systemerror);
    #####: 1043:		FreeMemory((farvoid *)bitarraybase,&systemerror);
    #####: 1044:		ErrorExit();
        -: 1045:	}
        -: 1046:}
        -: 1047:
        -: 1048:/*
        -: 1049:** All's well if we get here.  Repeatedly perform bitops until the
        -: 1050:** accumulated elapsed time is greater than # of seconds requested.
        -: 1051:*/
    #####: 1052:accumtime=0L;
    #####: 1053:iterations=(double)0.0;
        -: 1054:do {
    #####: 1055:	accumtime+=DoBitfieldIteration(bitarraybase,
        -: 1056:			bitoparraybase,
    #####: 1057:			locbitopstruct->bitoparraysize,&nbitops);
    #####: 1058:	iterations+=(double)nbitops;
    #####: 1059:} while(TicksToSecs(accumtime)<locbitopstruct->request_secs);
        -: 1060:
        -: 1061:/*
        -: 1062:** Clean up, calculate results, and go home.
        -: 1063:** Also, set adjustment flag to show that we don't have
        -: 1064:** to do self adjusting in the future.
        -: 1065:*/
    #####: 1066:FreeMemory((farvoid *)bitarraybase,&systemerror);
    #####: 1067:FreeMemory((farvoid *)bitoparraybase,&systemerror);
    #####: 1068:locbitopstruct->bitopspersec=iterations /TicksToFracSecs(accumtime);
    #####: 1069:if(locbitopstruct->adjust==0)
    #####: 1070:	locbitopstruct->adjust=1;
        -: 1071:
    #####: 1072:return;
        -: 1073:}
        -: 1074:
        -: 1075:/************************
        -: 1076:** DoBitfieldIteration **
        -: 1077:*************************
        -: 1078:** Perform a single iteration of the bitfield benchmark.
        -: 1079:** Return the # of ticks accumulated by the operation.
        -: 1080:*/
    #####: 1081:static ulong DoBitfieldIteration(farulong *bitarraybase,
        -: 1082:		farulong *bitoparraybase,
        -: 1083:		long bitoparraysize,
        -: 1084:		ulong *nbitops)
        -: 1085:{
        -: 1086:long i;                         /* Index */
        -: 1087:ulong bitoffset;                /* Offset into bitmap */
        -: 1088:ulong elapsed;                  /* Time to execute */
        -: 1089:/*
        -: 1090:** Clear # bitops counter
        -: 1091:*/
    #####: 1092:*nbitops=0L;
        -: 1093:
        -: 1094:/*
        -: 1095:** Construct a set of bitmap offsets and run lengths.
        -: 1096:** The offset can be any random number from 0 to the
        -: 1097:** size of the bitmap (in bits).  The run length can
        -: 1098:** be any random number from 1 to the number of bits
        -: 1099:** between the offset and the end of the bitmap.
        -: 1100:** Note that the bitmap has 8192 * 32 bits in it.
        -: 1101:** (262,144 bits)
        -: 1102:*/
        -: 1103:/*
        -: 1104:** Reset random number generator so things repeat.
        -: 1105:** Also reset the bit array we work on.
        -: 1106:** added by Uwe F. Mayer
        -: 1107:*/
    #####: 1108:randnum((int32)13);
    #####: 1109:for (i=0;i<global_bitopstruct.bitfieldarraysize;i++)
        -: 1110:{
        -: 1111:#ifdef LONG64
    #####: 1112:	*(bitarraybase+i)=(ulong)0x5555555555555555;
        -: 1113:#else
        -: 1114:	*(bitarraybase+i)=(ulong)0x55555555;
        -: 1115:#endif
        -: 1116:}
    #####: 1117:randnum((int32)13);
        -: 1118:/* end of addition of code */
        -: 1119:
    #####: 1120:for (i=0;i<bitoparraysize;i++)
        -: 1121:{
        -: 1122:	/* First item is offset */
        -: 1123:        /* *(bitoparraybase+i+i)=bitoffset=abs_randwc(262140L); */
    #####: 1124:	*(bitoparraybase+i+i)=bitoffset=abs_randwc((int32)262140);
        -: 1125:
        -: 1126:	/* Next item is run length */
        -: 1127:	/* *nbitops+=*(bitoparraybase+i+i+1L)=abs_randwc(262140L-bitoffset);*/
    #####: 1128:	*nbitops+=*(bitoparraybase+i+i+1L)=abs_randwc((int32)262140-bitoffset);
        -: 1129:}
        -: 1130:
        -: 1131:/*
        -: 1132:** Array of offset and lengths built...do an iteration of
        -: 1133:** the test.
        -: 1134:** Start the stopwatch.
        -: 1135:*/
    #####: 1136:elapsed=StartStopwatch();
        -: 1137:
        -: 1138:/*
        -: 1139:** Loop through array off offset/run length pairs.
        -: 1140:** Execute operation based on modulus of index.
        -: 1141:*/
    #####: 1142:for(i=0;i<bitoparraysize;i++)
        -: 1143:{
    #####: 1144:	switch(i % 3)
        -: 1145:	{
        -: 1146:
    #####: 1147:		case 0: /* Set run of bits */
    #####: 1148:			ToggleBitRun(bitarraybase,
    #####: 1149:				*(bitoparraybase+i+i),
    #####: 1150:				*(bitoparraybase+i+i+1),
        -: 1151:				1);
        -: 1152:			break;
        -: 1153:
    #####: 1154:		case 1: /* Clear run of bits */
    #####: 1155:			ToggleBitRun(bitarraybase,
    #####: 1156:				*(bitoparraybase+i+i),
    #####: 1157:				*(bitoparraybase+i+i+1),
        -: 1158:				0);
        -: 1159:			break;
        -: 1160:
    #####: 1161:		case 2: /* Complement run of bits */
    #####: 1162:			FlipBitRun(bitarraybase,
    #####: 1163:				*(bitoparraybase+i+i),
    #####: 1164:				*(bitoparraybase+i+i+1));
        -: 1165:			break;
        -: 1166:	}
        -: 1167:}
        -: 1168:
        -: 1169:/*
        -: 1170:** Return elapsed time
        -: 1171:*/
    #####: 1172:return(StopStopwatch(elapsed));
        -: 1173:}
        -: 1174:
        -: 1175:
        -: 1176:/*****************************
        -: 1177:**     ToggleBitRun          *
        -: 1178:******************************
        -: 1179:** Set or clear a run of nbits starting at
        -: 1180:** bit_addr in bitmap.
        -: 1181:*/
        -: 1182:static void ToggleBitRun(farulong *bitmap, /* Bitmap */
        -: 1183:		ulong bit_addr,         /* Address of bits to set */
        -: 1184:		ulong nbits,            /* # of bits to set/clr */
        -: 1185:		uint val)               /* 1 or 0 */
        -: 1186:{
        -: 1187:unsigned long bindex;   /* Index into array */
        -: 1188:unsigned long bitnumb;  /* Bit number */
        -: 1189:
    #####: 1190:while(nbits--)
        -: 1191:{
        -: 1192:#ifdef LONG64
    #####: 1193:	bindex=bit_addr>>6;     /* Index is number /64 */
    #####: 1194:	bitnumb=bit_addr % 64;   /* Bit number in word */
        -: 1195:#else
        -: 1196:	bindex=bit_addr>>5;     /* Index is number /32 */
        -: 1197:	bitnumb=bit_addr % 32;  /* bit number in word */
        -: 1198:#endif
        -: 1199:	if(val)
    #####: 1200:		bitmap[bindex]|=(1L<<bitnumb);
        -: 1201:	else
    #####: 1202:		bitmap[bindex]&=~(1L<<bitnumb);
    #####: 1203:	bit_addr++;
        -: 1204:}
        -: 1205:return;
        -: 1206:}
        -: 1207:
        -: 1208:/***************
        -: 1209:** FlipBitRun **
        -: 1210:****************
        -: 1211:** Complements a run of bits.
        -: 1212:*/
        -: 1213:static void FlipBitRun(farulong *bitmap,        /* Bit map */
        -: 1214:		ulong bit_addr,                 /* Bit address */
        -: 1215:		ulong nbits)                    /* # of bits to flip */
        -: 1216:{
        -: 1217:unsigned long bindex;   /* Index into array */
        -: 1218:unsigned long bitnumb;  /* Bit number */
        -: 1219:
    #####: 1220:while(nbits--)
        -: 1221:{
        -: 1222:#ifdef LONG64
    #####: 1223:	bindex=bit_addr>>6;     /* Index is number /64 */
    #####: 1224:	bitnumb=bit_addr % 64;  /* Bit number in longword */
        -: 1225:#else
        -: 1226:	bindex=bit_addr>>5;     /* Index is number /32 */
        -: 1227:	bitnumb=bit_addr % 32;  /* Bit number in longword */
        -: 1228:#endif
    #####: 1229:	bitmap[bindex]^=(1L<<bitnumb);
    #####: 1230:	bit_addr++;
        -: 1231:}
        -: 1232:
        -: 1233:return;
        -: 1234:}
        -: 1235:
        -: 1236:/*****************************
        -: 1237:** FLOATING-POINT EMULATION **
        -: 1238:*****************************/
        -: 1239:
        -: 1240:/**************
        -: 1241:** DoEmFloat **
        -: 1242:***************
        -: 1243:** Perform the floating-point emulation routines portion of the
        -: 1244:** CPU benchmark.  Returns the operations per second.
        -: 1245:*/
    #####: 1246:void DoEmFloat(void)
        -: 1247:{
        -: 1248:EmFloatStruct *locemfloatstruct;        /* Local structure */
        -: 1249:InternalFPF *abase;             /* Base of A array */
        -: 1250:InternalFPF *bbase;             /* Base of B array */
        -: 1251:InternalFPF *cbase;             /* Base of C array */
        -: 1252:ulong accumtime;                /* Accumulated time in ticks */
        -: 1253:double iterations;              /* # of iterations */
        -: 1254:ulong tickcount;                /* # of ticks */
        -: 1255:char *errorcontext;             /* Error context string pointer */
        -: 1256:int systemerror;                /* For holding error code */
        -: 1257:ulong loops;                    /* # of loops */
        -: 1258:
        -: 1259:/*
        -: 1260:** Link to global structure
        -: 1261:*/
    #####: 1262:locemfloatstruct=&global_emfloatstruct;
        -: 1263:
        -: 1264:/*
        -: 1265:** Set the error context
        -: 1266:*/
    #####: 1267:errorcontext="CPU:Floating Emulation";
        -: 1268:
        -: 1269:
        -: 1270:/*
        -: 1271:** Test the emulation routines.
        -: 1272:*/
        -: 1273:#ifdef DEBUG
        -: 1274:#endif
        -: 1275:
    #####: 1276:abase=(InternalFPF *)AllocateMemory(locemfloatstruct->arraysize*sizeof(InternalFPF),
        -: 1277:		&systemerror);
    #####: 1278:if(systemerror)
    #####: 1279:{       ReportError(errorcontext,systemerror);
    #####: 1280:	ErrorExit();
        -: 1281:}
        -: 1282:
    #####: 1283:bbase=(InternalFPF *)AllocateMemory(locemfloatstruct->arraysize*sizeof(InternalFPF),
        -: 1284:		&systemerror);
    #####: 1285:if(systemerror)
    #####: 1286:{       ReportError(errorcontext,systemerror);
    #####: 1287:	FreeMemory((farvoid *)abase,&systemerror);
    #####: 1288:	ErrorExit();
        -: 1289:}
        -: 1290:
    #####: 1291:cbase=(InternalFPF *)AllocateMemory(locemfloatstruct->arraysize*sizeof(InternalFPF),
        -: 1292:		&systemerror);
    #####: 1293:if(systemerror)
    #####: 1294:{       ReportError(errorcontext,systemerror);
    #####: 1295:	FreeMemory((farvoid *)abase,&systemerror);
    #####: 1296:	FreeMemory((farvoid *)bbase,&systemerror);
    #####: 1297:	ErrorExit();
        -: 1298:}
        -: 1299:
        -: 1300:/*
        -: 1301:** Set up the arrays
        -: 1302:*/
    #####: 1303:SetupCPUEmFloatArrays(abase,bbase,cbase,locemfloatstruct->arraysize);
        -: 1304:
        -: 1305:/*
        -: 1306:** See if we need to do self-adjusting code.
        -: 1307:*/
    #####: 1308:if(locemfloatstruct->adjust==0)
        -: 1309:{
    #####: 1310:	locemfloatstruct->loops=0;
        -: 1311:
        -: 1312:	/*
        -: 1313:	** Do an iteration of the tests.  If the elapsed time is
        -: 1314:	** less than minimum, increase the loop count and try
        -: 1315:	** again.
        -: 1316:	*/
    #####: 1317:	for(loops=1;loops<CPUEMFLOATLOOPMAX;loops+=loops)
    #####: 1318:	{       tickcount=DoEmFloatIteration(abase,bbase,cbase,
        -: 1319:			locemfloatstruct->arraysize,
        -: 1320:			loops);
    #####: 1321:		if(tickcount>global_min_ticks)
    #####: 1322:		{       locemfloatstruct->loops=loops;
    #####: 1323:			break;
        -: 1324:		}
        -: 1325:	}
        -: 1326:}
        -: 1327:
        -: 1328:/*
        -: 1329:** Verify that selft adjustment code worked.
        -: 1330:*/
    #####: 1331:if(locemfloatstruct->loops==0)
    #####: 1332:{       printf("CPU:EMFPU -- CMPUEMFLOATLOOPMAX limit hit\n");
    #####: 1333:	FreeMemory((farvoid *)abase,&systemerror);
    #####: 1334:	FreeMemory((farvoid *)bbase,&systemerror);
    #####: 1335:	FreeMemory((farvoid *)cbase,&systemerror);
    #####: 1336:	ErrorExit();
        -: 1337:}
        -: 1338:
        -: 1339:/*
        -: 1340:** All's well if we get here.  Repeatedly perform floating
        -: 1341:** tests until the accumulated time is greater than the
        -: 1342:** # of seconds requested.
        -: 1343:** Each iteration performs arraysize * 3 operations.
        -: 1344:*/
        -: 1345:accumtime=0L;
        -: 1346:iterations=(double)0.0;
        -: 1347:do {
    #####: 1348:	accumtime+=DoEmFloatIteration(abase,bbase,cbase,
        -: 1349:			locemfloatstruct->arraysize,
        -: 1350:			locemfloatstruct->loops);
    #####: 1351:	iterations+=(double)1.0;
    #####: 1352:} while(TicksToSecs(accumtime)<locemfloatstruct->request_secs);
        -: 1353:
        -: 1354:
        -: 1355:/*
        -: 1356:** Clean up, calculate results, and go home.
        -: 1357:** Also, indicate that adjustment is done.
        -: 1358:*/
    #####: 1359:FreeMemory((farvoid *)abase,&systemerror);
    #####: 1360:FreeMemory((farvoid *)bbase,&systemerror);
    #####: 1361:FreeMemory((farvoid *)cbase,&systemerror);
        -: 1362:
    #####: 1363:locemfloatstruct->emflops=(iterations*(double)locemfloatstruct->loops)/
    #####: 1364:		(double)TicksToFracSecs(accumtime);
    #####: 1365:if(locemfloatstruct->adjust==0)
    #####: 1366:	locemfloatstruct->adjust=1;
        -: 1367:
        -: 1368:#ifdef DEBUG
        -: 1369:printf("----------------------------------------------------------------------------\n");
        -: 1370:#endif
    #####: 1371:return;
        -: 1372:}
        -: 1373:
        -: 1374:/*************************
        -: 1375:** FOURIER COEFFICIENTS **
        -: 1376:*************************/
        -: 1377:
        -: 1378:/**************
        -: 1379:** DoFourier **
        -: 1380:***************
        -: 1381:** Perform the transcendental/trigonometric portion of the
        -: 1382:** benchmark.  This benchmark calculates the first n
        -: 1383:** fourier coefficients of the function (x+1)^x defined
        -: 1384:** on the interval 0,2.
        -: 1385:*/
    #####: 1386:void DoFourier(void)
        -: 1387:{
        -: 1388:FourierStruct *locfourierstruct;        /* Local fourier struct */
        -: 1389:fardouble *abase;               /* Base of A[] coefficients array */
        -: 1390:fardouble *bbase;               /* Base of B[] coefficients array */
        -: 1391:unsigned long accumtime;        /* Accumulated time in ticks */
        -: 1392:double iterations;              /* # of iterations */
        -: 1393:char *errorcontext;             /* Error context string pointer */
        -: 1394:int systemerror;                /* For error code */
        -: 1395:
        -: 1396:/*
        -: 1397:** Link to global structure
        -: 1398:*/
    #####: 1399:locfourierstruct=&global_fourierstruct;
        -: 1400:
        -: 1401:/*
        -: 1402:** Set error context string
        -: 1403:*/
    #####: 1404:errorcontext="FPU:Transcendental";
        -: 1405:
        -: 1406:/*
        -: 1407:** See if we need to do self-adjustment code.
        -: 1408:*/
    #####: 1409:if(locfourierstruct->adjust==0)
        -: 1410:{
    #####: 1411:	locfourierstruct->arraysize=100L;       /* Start at 100 elements */
        -: 1412:	while(1)
        -: 1413:	{
        -: 1414:
    #####: 1415:		abase=(fardouble *)AllocateMemory(locfourierstruct->arraysize*sizeof(double),
        -: 1416:				&systemerror);
    #####: 1417:		if(systemerror)
    #####: 1418:		{       ReportError(errorcontext,systemerror);
    #####: 1419:			ErrorExit();
        -: 1420:		}
        -: 1421:
    #####: 1422:		bbase=(fardouble *)AllocateMemory(locfourierstruct->arraysize*sizeof(double),
        -: 1423:				&systemerror);
    #####: 1424:		if(systemerror)
    #####: 1425:		{       ReportError(errorcontext,systemerror);
    #####: 1426:			FreeMemory((void *)abase,&systemerror);
    #####: 1427:			ErrorExit();
        -: 1428:		}
        -: 1429:		/*
        -: 1430:		** Do an iteration of the tests.  If the elapsed time is
        -: 1431:		** less than or equal to the permitted minimum, re-allocate
        -: 1432:		** larger arrays and try again.
        -: 1433:		*/
    #####: 1434:		if(DoFPUTransIteration(abase,bbase,
    #####: 1435:			locfourierstruct->arraysize)>global_min_ticks)
        -: 1436:			break;          /* We're ok...exit */
        -: 1437:
        -: 1438:		/*
        -: 1439:		** Make bigger arrays and try again.
        -: 1440:		*/
    #####: 1441:		FreeMemory((farvoid *)abase,&systemerror);
    #####: 1442:		FreeMemory((farvoid *)bbase,&systemerror);
    #####: 1443:		locfourierstruct->arraysize+=50L;
        -: 1444:	}
        -: 1445:}
        -: 1446:else
        -: 1447:{       /*
        -: 1448:	** Don't need self-adjustment.  Just allocate the
        -: 1449:	** arrays, and go.
        -: 1450:	*/
    #####: 1451:	abase=(fardouble *)AllocateMemory(locfourierstruct->arraysize*sizeof(double),
        -: 1452:			&systemerror);
    #####: 1453:	if(systemerror)
    #####: 1454:	{       ReportError(errorcontext,systemerror);
    #####: 1455:		ErrorExit();
        -: 1456:	}
        -: 1457:
    #####: 1458:	bbase=(fardouble *)AllocateMemory(locfourierstruct->arraysize*sizeof(double),
        -: 1459:			&systemerror);
    #####: 1460:	if(systemerror)
    #####: 1461:	{       ReportError(errorcontext,systemerror);
    #####: 1462:		FreeMemory((void *)abase,&systemerror);
    #####: 1463:		ErrorExit();
        -: 1464:	}
        -: 1465:}
        -: 1466:/*
        -: 1467:** All's well if we get here.  Repeatedly perform integration
        -: 1468:** tests until the accumulated time is greater than the
        -: 1469:** # of seconds requested.
        -: 1470:*/
    #####: 1471:accumtime=0L;
    #####: 1472:iterations=(double)0.0;
        -: 1473:do {
    #####: 1474:	accumtime+=DoFPUTransIteration(abase,bbase,locfourierstruct->arraysize);
    #####: 1475:	iterations+=(double)locfourierstruct->arraysize*(double)2.0-(double)1.0;
    #####: 1476:} while(TicksToSecs(accumtime)<locfourierstruct->request_secs);
        -: 1477:
        -: 1478:
        -: 1479:/*
        -: 1480:** Clean up, calculate results, and go home.
        -: 1481:** Also set adjustment flag to indicate no adjust code needed.
        -: 1482:*/
    #####: 1483:FreeMemory((farvoid *)abase,&systemerror);
    #####: 1484:FreeMemory((farvoid *)bbase,&systemerror);
        -: 1485:
    #####: 1486:locfourierstruct->fflops=iterations/(double)TicksToFracSecs(accumtime);
        -: 1487:
    #####: 1488:if(locfourierstruct->adjust==0)
    #####: 1489:	locfourierstruct->adjust=1;
        -: 1490:
    #####: 1491:return;
        -: 1492:}
        -: 1493:
        -: 1494:/************************
        -: 1495:** DoFPUTransIteration **
        -: 1496:*************************
        -: 1497:** Perform an iteration of the FPU Transcendental/trigonometric
        -: 1498:** benchmark.  Here, an iteration consists of calculating the
        -: 1499:** first n fourier coefficients of the function (x+1)^x on
        -: 1500:** the interval 0,2.  n is given by arraysize.
        -: 1501:** NOTE: The # of integration steps is fixed at
        -: 1502:** 200.
        -: 1503:*/
    #####: 1504:static ulong DoFPUTransIteration(fardouble *abase,      /* A coeffs. */
        -: 1505:			fardouble *bbase,               /* B coeffs. */
        -: 1506:			ulong arraysize)                /* # of coeffs */
        -: 1507:{
        -: 1508:double omega;           /* Fundamental frequency */
        -: 1509:unsigned long i;        /* Index */
        -: 1510:unsigned long elapsed;  /* Elapsed time */
        -: 1511:
        -: 1512:/*
        -: 1513:** Start the stopwatch
        -: 1514:*/
    #####: 1515:elapsed=StartStopwatch();
        -: 1516:
        -: 1517:/*
        -: 1518:** Calculate the fourier series.  Begin by
        -: 1519:** calculating A[0].
        -: 1520:*/
        -: 1521:
    #####: 1522:*abase=TrapezoidIntegrate((double)0.0,
        -: 1523:			(double)2.0,
        -: 1524:			200,
        -: 1525:			(double)0.0,    /* No omega * n needed */
    #####: 1526:			0 )/(double)2.0;
        -: 1527:
        -: 1528:/*
        -: 1529:** Calculate the fundamental frequency.
        -: 1530:** ( 2 * pi ) / period...and since the period
        -: 1531:** is 2, omega is simply pi.
        -: 1532:*/
    #####: 1533:omega=(double)3.1415926535897932;
        -: 1534:
    #####: 1535:for(i=1;i<arraysize;i++)
        -: 1536:{
        -: 1537:
        -: 1538:	/*
        -: 1539:	** Calculate A[i] terms.  Note, once again, that we
        -: 1540:	** can ignore the 2/period term outside the integral
        -: 1541:	** since the period is 2 and the term cancels itself
        -: 1542:	** out.
        -: 1543:	*/
    #####: 1544:	*(abase+i)=TrapezoidIntegrate((double)0.0,
        -: 1545:			(double)2.0,
        -: 1546:			200,
    #####: 1547:			omega * (double)i,
        -: 1548:			1);
        -: 1549:
        -: 1550:	/*
        -: 1551:	** Calculate the B[i] terms.
        -: 1552:	*/
    #####: 1553:	*(bbase+i)=TrapezoidIntegrate((double)0.0,
        -: 1554:			(double)2.0,
        -: 1555:			200,
        -: 1556:			omega * (double)i,
        -: 1557:			2);
        -: 1558:
        -: 1559:}
        -: 1560:#ifdef DEBUG
        -: 1561:{
        -: 1562:  int i;
        -: 1563:  printf("\nA[i]=\n");
        -: 1564:  for (i=0;i<arraysize;i++) printf("%7.3g ",abase[i]);
        -: 1565:  printf("\nB[i]=\n(undefined) ");
        -: 1566:  for (i=1;i<arraysize;i++) printf("%7.3g ",bbase[i]);
        -: 1567:}
        -: 1568:#endif
        -: 1569:/*
        -: 1570:** All done, stop the stopwatch
        -: 1571:*/
    #####: 1572:return(StopStopwatch(elapsed));
        -: 1573:}
        -: 1574:
        -: 1575:/***********************
        -: 1576:** TrapezoidIntegrate **
        -: 1577:************************
        -: 1578:** Perform a simple trapezoid integration on the
        -: 1579:** function (x+1)**x.
        -: 1580:** x0,x1 set the lower and upper bounds of the
        -: 1581:** integration.
        -: 1582:** nsteps indicates # of trapezoidal sections
        -: 1583:** omegan is the fundamental frequency times
        -: 1584:**  the series member #
        -: 1585:** select = 0 for the A[0] term, 1 for cosine terms, and
        -: 1586:**   2 for sine terms.
        -: 1587:** Returns the value.
        -: 1588:*/
    #####: 1589:static double TrapezoidIntegrate( double x0,            /* Lower bound */
        -: 1590:			double x1,              /* Upper bound */
        -: 1591:			int nsteps,             /* # of steps */
        -: 1592:			double omegan,          /* omega * n */
        -: 1593:			int select)
        -: 1594:{
        -: 1595:double x;               /* Independent variable */
        -: 1596:double dx;              /* Stepsize */
        -: 1597:double rvalue;          /* Return value */
        -: 1598:
        -: 1599:
        -: 1600:/*
        -: 1601:** Initialize independent variable
        -: 1602:*/
    #####: 1603:x=x0;
        -: 1604:
        -: 1605:/*
        -: 1606:** Calculate stepsize
        -: 1607:*/
    #####: 1608:dx=(x1 - x0) / (double)nsteps;
        -: 1609:
        -: 1610:/*
        -: 1611:** Initialize the return value.
        -: 1612:*/
    #####: 1613:rvalue=thefunction(x0,omegan,select)/(double)2.0;
        -: 1614:
        -: 1615:/*
        -: 1616:** Compute the other terms of the integral.
        -: 1617:*/
    #####: 1618:if(nsteps!=1)
    #####: 1619:{       --nsteps;               /* Already done 1 step */
    #####: 1620:	while(--nsteps )
        -: 1621:	{
    #####: 1622:		x+=dx;
    #####: 1623:		rvalue+=thefunction(x,omegan,select);
        -: 1624:	}
        -: 1625:}
        -: 1626:/*
        -: 1627:** Finish computation
        -: 1628:*/
    #####: 1629:rvalue=(rvalue+thefunction(x1,omegan,select)/(double)2.0)*dx;
        -: 1630:
    #####: 1631:return(rvalue);
        -: 1632:}
        -: 1633:
        -: 1634:/****************
        -: 1635:** thefunction **
        -: 1636:*****************
        -: 1637:** This routine selects the function to be used
        -: 1638:** in the Trapezoid integration.
        -: 1639:** x is the independent variable
        -: 1640:** omegan is omega * n
        -: 1641:** select chooses which of the sine/cosine functions
        -: 1642:**  are used.  note the special case for select=0.
        -: 1643:*/
    #####: 1644:static double thefunction(double x,             /* Independent variable */
        -: 1645:		double omegan,          /* Omega * term */
        -: 1646:		int select)             /* Choose term */
        -: 1647:{
        -: 1648:
        -: 1649:/*
        -: 1650:** Use select to pick which function we call.
        -: 1651:*/
    #####: 1652:switch(select)
        -: 1653:{
    #####: 1654:	case 0: return(pow(x+(double)1.0,x));
        -: 1655:
    #####: 1656:	case 1: return(pow(x+(double)1.0,x) * cos(omegan * x));
        -: 1657:
    #####: 1658:	case 2: return(pow(x+(double)1.0,x) * sin(omegan * x));
        -: 1659:}
        -: 1660:
        -: 1661:/*
        -: 1662:** We should never reach this point, but the following
        -: 1663:** keeps compilers from issuing a warning message.
        -: 1664:*/
        -: 1665:return(0.0);
        -: 1666:}
        -: 1667:
        -: 1668:/*************************
        -: 1669:** ASSIGNMENT ALGORITHM **
        -: 1670:*************************/
        -: 1671:
        -: 1672:/*************
        -: 1673:** DoAssign **
        -: 1674:**************
        -: 1675:** Perform an assignment algorithm.
        -: 1676:** The algorithm was adapted from the step by step guide found
        -: 1677:** in "Quantitative Decision Making for Business" (Gordon,
        -: 1678:**  Pressman, and Cohn; Prentice-Hall)
        -: 1679:**
        -: 1680:**
        -: 1681:** NOTES:
        -: 1682:** 1. Even though the algorithm distinguishes between
        -: 1683:**    ASSIGNROWS and ASSIGNCOLS, as though the two might
        -: 1684:**    be different, it does presume a square matrix.
        -: 1685:**    I.E., ASSIGNROWS and ASSIGNCOLS must be the same.
        -: 1686:**    This makes for some algorithmically-correct but
        -: 1687:**    probably non-optimal constructs.
        -: 1688:**
        -: 1689:*/
    #####: 1690:void DoAssign(void)
        -: 1691:{
        -: 1692:AssignStruct *locassignstruct;  /* Local structure ptr */
        -: 1693:farlong *arraybase;
        -: 1694:char *errorcontext;
        -: 1695:int systemerror;
        -: 1696:ulong accumtime;
        -: 1697:double iterations;
        -: 1698:
        -: 1699:/*
        -: 1700:** Link to global structure
        -: 1701:*/
    #####: 1702:locassignstruct=&global_assignstruct;
        -: 1703:
        -: 1704:/*
        -: 1705:** Set the error context string.
        -: 1706:*/
    #####: 1707:errorcontext="CPU:Assignment";
        -: 1708:
        -: 1709:/*
        -: 1710:** See if we need to do self adjustment code.
        -: 1711:*/
    #####: 1712:if(locassignstruct->adjust==0)
        -: 1713:{
        -: 1714:	/*
        -: 1715:	** Self-adjustment code.  The system begins by working on 1
        -: 1716:	** array.  If it does that in no time, then two arrays
        -: 1717:	** are built.  This process continues until
        -: 1718:	** enough arrays are built to handle the tolerance.
        -: 1719:	*/
    #####: 1720:	locassignstruct->numarrays=1;
        -: 1721:	while(1)
        -: 1722:	{
        -: 1723:		/*
        -: 1724:		** Allocate space for arrays
        -: 1725:		*/
    #####: 1726:		arraybase=(farlong *) AllocateMemory(sizeof(long)*
    #####: 1727:			ASSIGNROWS*ASSIGNCOLS*locassignstruct->numarrays,
        -: 1728:			 &systemerror);
    #####: 1729:		if(systemerror)
    #####: 1730:		{       ReportError(errorcontext,systemerror);
    #####: 1731:			FreeMemory((farvoid *)arraybase,
        -: 1732:			  &systemerror);
    #####: 1733:			ErrorExit();
        -: 1734:		}
        -: 1735:
        -: 1736:		/*
        -: 1737:		** Do an iteration of the assignment alg.  If the
        -: 1738:		** elapsed time is less than or equal to the permitted
        -: 1739:		** minimum, then allocate for more arrays and
        -: 1740:		** try again.
        -: 1741:		*/
    #####: 1742:		if(DoAssignIteration(arraybase,
    #####: 1743:			locassignstruct->numarrays)>global_min_ticks)
        -: 1744:			break;          /* We're ok...exit */
        -: 1745:
    #####: 1746:		FreeMemory((farvoid *)arraybase, &systemerror);
    #####: 1747:		locassignstruct->numarrays++;
        -: 1748:	}
        -: 1749:}
        -: 1750:else
        -: 1751:{       /*
        -: 1752:	** Allocate space for arrays
        -: 1753:	*/
    #####: 1754:	arraybase=(farlong *)AllocateMemory(sizeof(long)*
    #####: 1755:		ASSIGNROWS*ASSIGNCOLS*locassignstruct->numarrays,
        -: 1756:		 &systemerror);
    #####: 1757:	if(systemerror)
    #####: 1758:	{       ReportError(errorcontext,systemerror);
    #####: 1759:		FreeMemory((farvoid *)arraybase,
        -: 1760:		  &systemerror);
    #####: 1761:		ErrorExit();
        -: 1762:	}
        -: 1763:}
        -: 1764:
        -: 1765:/*
        -: 1766:** All's well if we get here.  Do the tests.
        -: 1767:*/
    #####: 1768:accumtime=0L;
    #####: 1769:iterations=(double)0.0;
        -: 1770:
        -: 1771:do {
    #####: 1772:	accumtime+=DoAssignIteration(arraybase,
        -: 1773:		locassignstruct->numarrays);
    #####: 1774:	iterations+=(double)1.0;
    #####: 1775:} while(TicksToSecs(accumtime)<locassignstruct->request_secs);
        -: 1776:
        -: 1777:/*
        -: 1778:** Clean up, calculate results, and go home.  Be sure to
        -: 1779:** show that we don't have to rerun adjustment code.
        -: 1780:*/
    #####: 1781:FreeMemory((farvoid *)arraybase,&systemerror);
        -: 1782:
    #####: 1783:locassignstruct->iterspersec=iterations *
    #####: 1784:	(double)locassignstruct->numarrays / TicksToFracSecs(accumtime);
        -: 1785:
    #####: 1786:if(locassignstruct->adjust==0)
    #####: 1787:	locassignstruct->adjust=1;
        -: 1788:
    #####: 1789:return;
        -: 1790:
        -: 1791:}
        -: 1792:
        -: 1793:/**********************
        -: 1794:** DoAssignIteration **
        -: 1795:***********************
        -: 1796:** This routine executes one iteration of the assignment test.
        -: 1797:** It returns the number of ticks elapsed in the iteration.
        -: 1798:*/
    #####: 1799:static ulong DoAssignIteration(farlong *arraybase,
        -: 1800:	ulong numarrays)
        -: 1801:{
        -: 1802:longptr abase;                  /* local pointer */
        -: 1803:ulong elapsed;          /* Elapsed ticks */
        -: 1804:ulong i;
        -: 1805:
        -: 1806:/*
        -: 1807:** Set up local pointer
        -: 1808:*/
    #####: 1809:abase.ptrs.p=arraybase;
        -: 1810:
        -: 1811:/*
        -: 1812:** Load up the arrays with a random table.
        -: 1813:*/
    #####: 1814:LoadAssignArrayWithRand(arraybase,numarrays);
        -: 1815:
        -: 1816:/*
        -: 1817:** Start the stopwatch
        -: 1818:*/
    #####: 1819:elapsed=StartStopwatch();
        -: 1820:
        -: 1821:/*
        -: 1822:** Execute assignment algorithms
        -: 1823:*/
    #####: 1824:for(i=0;i<numarrays;i++)
        -: 1825:{       /* abase.ptrs.p+=i*ASSIGNROWS*ASSIGNCOLS; */
        -: 1826:        /* Fixed  by Eike Dierks */
    #####: 1827:	Assignment(*abase.ptrs.ap);
    #####: 1828:	abase.ptrs.p+=ASSIGNROWS*ASSIGNCOLS;
        -: 1829:}
        -: 1830:
        -: 1831:/*
        -: 1832:** Get elapsed time
        -: 1833:*/
    #####: 1834:return(StopStopwatch(elapsed));
        -: 1835:}
        -: 1836:
        -: 1837:/****************************
        -: 1838:** LoadAssignArrayWithRand **
        -: 1839:*****************************
        -: 1840:** Load the assignment arrays with random numbers.  All positive.
        -: 1841:** These numbers represent costs.
        -: 1842:*/
    #####: 1843:static void LoadAssignArrayWithRand(farlong *arraybase,
        -: 1844:	ulong numarrays)
        -: 1845:{
        -: 1846:longptr abase,abase1;   /* Local for array pointer */
        -: 1847:ulong i;
        -: 1848:
        -: 1849:/*
        -: 1850:** Set local array pointer
        -: 1851:*/
    #####: 1852:abase.ptrs.p=arraybase;
    #####: 1853:abase1.ptrs.p=arraybase;
        -: 1854:
        -: 1855:/*
        -: 1856:** Set up the first array.  Then just copy it into the
        -: 1857:** others.
        -: 1858:*/
    #####: 1859:LoadAssign(*(abase.ptrs.ap));
    #####: 1860:if(numarrays>1)
    #####: 1861:	for(i=1;i<numarrays;i++)
        -: 1862:	  {     /* abase1.ptrs.p+=i*ASSIGNROWS*ASSIGNCOLS; */
        -: 1863:	        /* Fixed  by Eike Dierks */
    #####: 1864:	        abase1.ptrs.p+=ASSIGNROWS*ASSIGNCOLS;
    #####: 1865:		CopyToAssign(*(abase.ptrs.ap),*(abase1.ptrs.ap));
        -: 1866:	}
        -: 1867:
    #####: 1868:return;
        -: 1869:}
        -: 1870:
        -: 1871:/***************
        -: 1872:** LoadAssign **
        -: 1873:****************
        -: 1874:** The array given by arraybase is loaded with positive random
        -: 1875:** numbers.  Elements in the array are capped at 5,000,000.
        -: 1876:*/
    #####: 1877:static void LoadAssign(farlong arraybase[][ASSIGNCOLS])
        -: 1878:{
        -: 1879:ushort i,j;
        -: 1880:
        -: 1881:/*
        -: 1882:** Reset random number generator so things repeat.
        -: 1883:*/
        -: 1884:/* randnum(13L); */
    #####: 1885:randnum((int32)13);
        -: 1886:
    #####: 1887:for(i=0;i<ASSIGNROWS;i++)
    #####: 1888:  for(j=0;j<ASSIGNROWS;j++){
        -: 1889:    /* arraybase[i][j]=abs_randwc(5000000L);*/
    #####: 1890:    arraybase[i][j]=abs_randwc((int32)5000000);
        -: 1891:  }
        -: 1892:
    #####: 1893:return;
        -: 1894:}
        -: 1895:
        -: 1896:/*****************
        -: 1897:** CopyToAssign **
        -: 1898:******************
        -: 1899:** Copy the contents of one array to another.  This is called by
        -: 1900:** the routine that builds the initial array, and is used to copy
        -: 1901:** the contents of the intial array into all following arrays.
        -: 1902:*/
        -: 1903:static void CopyToAssign(farlong arrayfrom[ASSIGNROWS][ASSIGNCOLS],
        -: 1904:		farlong arrayto[ASSIGNROWS][ASSIGNCOLS])
        -: 1905:{
        -: 1906:ushort i,j;
        -: 1907:
    #####: 1908:for(i=0;i<ASSIGNROWS;i++)
    #####: 1909:	for(j=0;j<ASSIGNCOLS;j++)
    #####: 1910:		arrayto[i][j]=arrayfrom[i][j];
        -: 1911:
        -: 1912:return;
        -: 1913:}
        -: 1914:
        -: 1915:/***************
        -: 1916:** Assignment **
        -: 1917:***************/
    #####: 1918:static void Assignment(farlong arraybase[][ASSIGNCOLS])
        -: 1919:{
        -: 1920:short assignedtableau[ASSIGNROWS][ASSIGNCOLS];
        -: 1921:
        -: 1922:/*
        -: 1923:** First, calculate minimum costs
        -: 1924:*/
    #####: 1925:calc_minimum_costs(arraybase);
        -: 1926:
        -: 1927:/*
        -: 1928:** Repeat following until the number of rows selected
        -: 1929:** equals the number of rows in the tableau.
        -: 1930:*/
    #####: 1931:while(first_assignments(arraybase,assignedtableau)!=ASSIGNROWS)
    #####: 1932:{         second_assignments(arraybase,assignedtableau);
        -: 1933:}
        -: 1934:
        -: 1935:#ifdef DEBUG
        -: 1936:{
        -: 1937:	int i,j;
        -: 1938:	printf("\nColumn choices for each row\n");
        -: 1939:	for(i=0;i<ASSIGNROWS;i++)
        -: 1940:	{
        -: 1941:	        printf("R%03d: ",i);
        -: 1942:		for(j=0;j<ASSIGNCOLS;j++)
        -: 1943:			if(assignedtableau[i][j]==1)
        -: 1944:				printf("%03d ",j);
        -: 1945:	}
        -: 1946:}
        -: 1947:#endif
        -: 1948:
    #####: 1949:return;
        -: 1950:}
        -: 1951:
        -: 1952:/***********************
        -: 1953:** calc_minimum_costs **
        -: 1954:************************
        -: 1955:** Revise the tableau by calculating the minimum costs on a
        -: 1956:** row and column basis.  These minima are subtracted from
        -: 1957:** their rows and columns, creating a new tableau.
        -: 1958:*/
    #####: 1959:static void calc_minimum_costs(long tableau[][ASSIGNCOLS])
        -: 1960:{
        -: 1961:ushort i,j;              /* Index variables */
        -: 1962:long currentmin;        /* Current minimum */
        -: 1963:/*
        -: 1964:** Determine minimum costs on row basis.  This is done by
        -: 1965:** subtracting -- on a row-per-row basis -- the minum value
        -: 1966:** for that row.
        -: 1967:*/
    #####: 1968:for(i=0;i<ASSIGNROWS;i++)
        -: 1969:{
        -: 1970:	currentmin=MAXPOSLONG;  /* Initialize minimum */
    #####: 1971:	for(j=0;j<ASSIGNCOLS;j++)
    #####: 1972:		if(tableau[i][j]<currentmin)
    #####: 1973:			currentmin=tableau[i][j];
        -: 1974:
    #####: 1975:	for(j=0;j<ASSIGNCOLS;j++)
    #####: 1976:		tableau[i][j]-=currentmin;
        -: 1977:}
        -: 1978:
        -: 1979:/*
        -: 1980:** Determine minimum cost on a column basis.  This works
        -: 1981:** just as above, only now we step through the array
        -: 1982:** column-wise
        -: 1983:*/
    #####: 1984:for(j=0;j<ASSIGNCOLS;j++)
        -: 1985:{
        -: 1986:	currentmin=MAXPOSLONG;  /* Initialize minimum */
    #####: 1987:	for(i=0;i<ASSIGNROWS;i++)
    #####: 1988:		if(tableau[i][j]<currentmin)
    #####: 1989:			currentmin=tableau[i][j];
        -: 1990:
        -: 1991:	/*
        -: 1992:	** Here, we'll take the trouble to see if the current
        -: 1993:	** minimum is zero.  This is likely worth it, since the
        -: 1994:	** preceding loop will have created at least one zero in
        -: 1995:	** each row.  We can save ourselves a few iterations.
        -: 1996:	*/
    #####: 1997:	if(currentmin!=0)
    #####: 1998:		for(i=0;i<ASSIGNROWS;i++)
    #####: 1999:			tableau[i][j]-=currentmin;
        -: 2000:}
        -: 2001:
    #####: 2002:return;
        -: 2003:}
        -: 2004:
        -: 2005:/**********************
        -: 2006:** first_assignments **
        -: 2007:***********************
        -: 2008:** Do first assignments.
        -: 2009:** The assignedtableau[] array holds a set of values that
        -: 2010:** indicate the assignment of a value, or its elimination.
        -: 2011:** The values are:
        -: 2012:**      0 = Item is neither assigned nor eliminated.
        -: 2013:**      1 = Item is assigned
        -: 2014:**      2 = Item is eliminated
        -: 2015:** Returns the number of selections made.  If this equals
        -: 2016:** the number of rows, then an optimum has been determined.
        -: 2017:*/
    #####: 2018:static int first_assignments(long tableau[][ASSIGNCOLS],
        -: 2019:		short assignedtableau[][ASSIGNCOLS])
        -: 2020:{
        -: 2021:ushort i,j,k;                   /* Index variables */
        -: 2022:ushort numassigns;              /* # of assignments */
        -: 2023:ushort totnumassigns;           /* Total # of assignments */
        -: 2024:ushort numzeros;                /* # of zeros in row */
    #####: 2025:int selected=0;                 /* Flag used to indicate selection */
        -: 2026:
        -: 2027:/*
        -: 2028:** Clear the assignedtableau, setting all members to show that
        -: 2029:** no one is yet assigned, eliminated, or anything.
        -: 2030:*/
    #####: 2031:for(i=0;i<ASSIGNROWS;i++)
    #####: 2032:	for(j=0;j<ASSIGNCOLS;j++)
    #####: 2033:		assignedtableau[i][j]=0;
        -: 2034:
        -: 2035:totnumassigns=0;
        -: 2036:do {
    #####: 2037:	numassigns=0;
        -: 2038:	/*
        -: 2039:	** Step through rows.  For each one that is not currently
        -: 2040:	** assigned, see if the row has only one zero in it.  If so,
        -: 2041:	** mark that as an assigned row/col.  Eliminate other zeros
        -: 2042:	** in the same column.
        -: 2043:	*/
    #####: 2044:	for(i=0;i<ASSIGNROWS;i++)
        -: 2045:	{       numzeros=0;
    #####: 2046:		for(j=0;j<ASSIGNCOLS;j++)
    #####: 2047:			if(tableau[i][j]==0L)
    #####: 2048:				if(assignedtableau[i][j]==0)
    #####: 2049:				{       numzeros++;
    #####: 2050:					selected=j;
        -: 2051:				}
    #####: 2052:		if(numzeros==1)
    #####: 2053:		{       numassigns++;
    #####: 2054:			totnumassigns++;
    #####: 2055:			assignedtableau[i][selected]=1;
    #####: 2056:			for(k=0;k<ASSIGNROWS;k++)
    #####: 2057:				if((k!=i) &&
    #####: 2058:				   (tableau[k][selected]==0))
    #####: 2059:					assignedtableau[k][selected]=2;
        -: 2060:		}
        -: 2061:	}
        -: 2062:	/*
        -: 2063:	** Step through columns, doing same as above.  Now, be careful
        -: 2064:	** of items in the other rows of a selected column.
        -: 2065:	*/
    #####: 2066:	for(j=0;j<ASSIGNCOLS;j++)
        -: 2067:	{       numzeros=0;
    #####: 2068:		for(i=0;i<ASSIGNROWS;i++)
    #####: 2069:			if(tableau[i][j]==0L)
    #####: 2070:				if(assignedtableau[i][j]==0)
    #####: 2071:				{       numzeros++;
    #####: 2072:					selected=i;
        -: 2073:				}
    #####: 2074:		if(numzeros==1)
    #####: 2075:		{       numassigns++;
    #####: 2076:			totnumassigns++;
    #####: 2077:			assignedtableau[selected][j]=1;
    #####: 2078:			for(k=0;k<ASSIGNCOLS;k++)
    #####: 2079:				if((k!=j) &&
    #####: 2080:				   (tableau[selected][k]==0))
    #####: 2081:					assignedtableau[selected][k]=2;
        -: 2082:		}
        -: 2083:	}
        -: 2084:	/*
        -: 2085:	** Repeat until no more assignments to be made.
        -: 2086:	*/
    #####: 2087:} while(numassigns!=0);
        -: 2088:
        -: 2089:/*
        -: 2090:** See if we can leave at this point.
        -: 2091:*/
    #####: 2092:if(totnumassigns==ASSIGNROWS) return(totnumassigns);
        -: 2093:
        -: 2094:/*
        -: 2095:** Now step through the array by row.  If you find any unassigned
        -: 2096:** zeros, pick the first in the row.  Eliminate all zeros from
        -: 2097:** that same row & column.  This occurs if there are multiple optima...
        -: 2098:** possibly.
        -: 2099:*/
    #####: 2100:for(i=0;i<ASSIGNROWS;i++)
        -: 2101:{       selected=-1;
    #####: 2102:	for(j=0;j<ASSIGNCOLS;j++)
    #####: 2103:		if((tableau[i][j]==0L) &&
    #####: 2104:		   (assignedtableau[i][j]==0))
        -: 2105:		{       selected=j;
        -: 2106:			break;
        -: 2107:		}
    #####: 2108:	if(selected!=-1)
    #####: 2109:	{       assignedtableau[i][selected]=1;
    #####: 2110:		totnumassigns++;
    #####: 2111:		for(k=0;k<ASSIGNCOLS;k++)
    #####: 2112:			if((k!=selected) &&
    #####: 2113:			   (tableau[i][k]==0L))
    #####: 2114:				assignedtableau[i][k]=2;
    #####: 2115:		for(k=0;k<ASSIGNROWS;k++)
    #####: 2116:			if((k!=i) &&
    #####: 2117:			   (tableau[k][selected]==0L))
    #####: 2118:				assignedtableau[k][selected]=2;
        -: 2119:	}
        -: 2120:}
        -: 2121:
    #####: 2122:return(totnumassigns);
        -: 2123:}
        -: 2124:
        -: 2125:/***********************
        -: 2126:** second_assignments **
        -: 2127:************************
        -: 2128:** This section of the algorithm creates the revised
        -: 2129:** tableau, and is difficult to explain.  I suggest you
        -: 2130:** refer to the algorithm's source, mentioned in comments
        -: 2131:** toward the beginning of the program.
        -: 2132:*/
    #####: 2133:static void second_assignments(long tableau[][ASSIGNCOLS],
        -: 2134:		short assignedtableau[][ASSIGNCOLS])
        -: 2135:{
        -: 2136:int i,j;                                /* Indexes */
        -: 2137:short linesrow[ASSIGNROWS];
        -: 2138:short linescol[ASSIGNCOLS];
        -: 2139:long smallest;                          /* Holds smallest value */
        -: 2140:ushort numassigns;                      /* Number of assignments */
        -: 2141:ushort newrows;                         /* New rows to be considered */
        -: 2142:/*
        -: 2143:** Clear the linesrow and linescol arrays.
        -: 2144:*/
    #####: 2145:for(i=0;i<ASSIGNROWS;i++)
    #####: 2146:	linesrow[i]=0;
    #####: 2147:for(i=0;i<ASSIGNCOLS;i++)
    #####: 2148:	linescol[i]=0;
        -: 2149:
        -: 2150:/*
        -: 2151:** Scan rows, flag each row that has no assignment in it.
        -: 2152:*/
    #####: 2153:for(i=0;i<ASSIGNROWS;i++)
        -: 2154:{       numassigns=0;
    #####: 2155:	for(j=0;j<ASSIGNCOLS;j++)
    #####: 2156:		if(assignedtableau[i][j]==1)
        -: 2157:		{       numassigns++;
        -: 2158:			break;
        -: 2159:		}
    #####: 2160:	if(numassigns==0) linesrow[i]=1;
        -: 2161:}
        -: 2162:
        -: 2163:do {
        -: 2164:
    #####: 2165:	newrows=0;
        -: 2166:	/*
        -: 2167:	** For each row checked above, scan for any zeros.  If found,
        -: 2168:	** check the associated column.
        -: 2169:	*/
    #####: 2170:	for(i=0;i<ASSIGNROWS;i++)
    #####: 2171:	{       if(linesrow[i]==1)
    #####: 2172:			for(j=0;j<ASSIGNCOLS;j++)
    #####: 2173:				if(tableau[i][j]==0)
    #####: 2174:					linescol[j]=1;
        -: 2175:	}
        -: 2176:
        -: 2177:	/*
        -: 2178:	** Now scan checked columns.  If any contain assigned zeros, check
        -: 2179:	** the associated row.
        -: 2180:	*/
    #####: 2181:	for(j=0;j<ASSIGNCOLS;j++)
    #####: 2182:		if(linescol[j]==1)
    #####: 2183:			for(i=0;i<ASSIGNROWS;i++)
    #####: 2184:				if((assignedtableau[i][j]==1) &&
    #####: 2185:					(linesrow[i]!=1))
        -: 2186:				{
    #####: 2187:					linesrow[i]=1;
    #####: 2188:					newrows++;
        -: 2189:				}
    #####: 2190:} while(newrows!=0);
        -: 2191:
        -: 2192:/*
        -: 2193:** linesrow[n]==0 indicate rows covered by imaginary line
        -: 2194:** linescol[n]==1 indicate cols covered by imaginary line
        -: 2195:** For all cells not covered by imaginary lines, determine smallest
        -: 2196:** value.
        -: 2197:*/
        -: 2198:smallest=MAXPOSLONG;
    #####: 2199:for(i=0;i<ASSIGNROWS;i++)
    #####: 2200:	if(linesrow[i]!=0)
    #####: 2201:		for(j=0;j<ASSIGNCOLS;j++)
    #####: 2202:			if(linescol[j]!=1)
    #####: 2203:				if(tableau[i][j]<smallest)
    #####: 2204:					smallest=tableau[i][j];
        -: 2205:
        -: 2206:/*
        -: 2207:** Subtract smallest from all cells in the above set.
        -: 2208:*/
    #####: 2209:for(i=0;i<ASSIGNROWS;i++)
    #####: 2210:	if(linesrow[i]!=0)
    #####: 2211:		for(j=0;j<ASSIGNCOLS;j++)
    #####: 2212:			if(linescol[j]!=1)
    #####: 2213:				tableau[i][j]-=smallest;
        -: 2214:
        -: 2215:/*
        -: 2216:** Add smallest to all cells covered by two lines.
        -: 2217:*/
    #####: 2218:for(i=0;i<ASSIGNROWS;i++)
    #####: 2219:	if(linesrow[i]==0)
    #####: 2220:		for(j=0;j<ASSIGNCOLS;j++)
    #####: 2221:			if(linescol[j]==1)
    #####: 2222:				tableau[i][j]+=smallest;
        -: 2223:
    #####: 2224:return;
        -: 2225:}
        -: 2226:
        -: 2227:/********************
        -: 2228:** IDEA Encryption **
        -: 2229:*********************
        -: 2230:** IDEA - International Data Encryption Algorithm.
        -: 2231:** Based on code presented in Applied Cryptography by Bruce Schneier.
        -: 2232:** Which was based on code developed by Xuejia Lai and James L. Massey.
        -: 2233:** Other modifications made by Colin Plumb.
        -: 2234:**
        -: 2235:*/
        -: 2236:
        -: 2237:/***********
        -: 2238:** DoIDEA **
        -: 2239:************
        -: 2240:** Perform IDEA encryption.  Note that we time encryption & decryption
        -: 2241:** time as being a single loop.
        -: 2242:*/
    #####: 2243:void DoIDEA(void)
        -: 2244:{
        -: 2245:IDEAStruct *locideastruct;      /* Loc pointer to global structure */
        -: 2246:int i;
        -: 2247:IDEAkey Z,DK;
        -: 2248:u16 userkey[8];
        -: 2249:ulong accumtime;
        -: 2250:double iterations;
        -: 2251:char *errorcontext;
        -: 2252:int systemerror;
        -: 2253:faruchar *plain1;               /* First plaintext buffer */
        -: 2254:faruchar *crypt1;               /* Encryption buffer */
        -: 2255:faruchar *plain2;               /* Second plaintext buffer */
        -: 2256:
        -: 2257:/*
        -: 2258:** Link to global data
        -: 2259:*/
    #####: 2260:locideastruct=&global_ideastruct;
        -: 2261:
        -: 2262:/*
        -: 2263:** Set error context
        -: 2264:*/
    #####: 2265:errorcontext="CPU:IDEA";
        -: 2266:
        -: 2267:/*
        -: 2268:** Re-init random-number generator.
        -: 2269:*/
        -: 2270:/* randnum(3L); */
    #####: 2271:randnum((int32)3);
        -: 2272:
        -: 2273:/*
        -: 2274:** Build an encryption/decryption key
        -: 2275:*/
    #####: 2276:for (i=0;i<8;i++)
        -: 2277:        /* userkey[i]=(u16)(abs_randwc(60000L) & 0xFFFF); */
    #####: 2278:	userkey[i]=(u16)(abs_randwc((int32)60000) & 0xFFFF);
    #####: 2279:for(i=0;i<KEYLEN;i++)
    #####: 2280:	Z[i]=0;
        -: 2281:
        -: 2282:/*
        -: 2283:** Compute encryption/decryption subkeys
        -: 2284:*/
    #####: 2285:en_key_idea(userkey,Z);
    #####: 2286:de_key_idea(Z,DK);
        -: 2287:
        -: 2288:/*
        -: 2289:** Allocate memory for buffers.  We'll make 3, called plain1,
        -: 2290:** crypt1, and plain2.  It works like this:
        -: 2291:**   plain1 >>encrypt>> crypt1 >>decrypt>> plain2.
        -: 2292:** So, plain1 and plain2 should match.
        -: 2293:** Also, fill up plain1 with sample text.
        -: 2294:*/
    #####: 2295:plain1=(faruchar *)AllocateMemory(locideastruct->arraysize,&systemerror);
    #####: 2296:if(systemerror)
        -: 2297:{
    #####: 2298:	ReportError(errorcontext,systemerror);
    #####: 2299:	ErrorExit();
        -: 2300:}
        -: 2301:
    #####: 2302:crypt1=(faruchar *)AllocateMemory(locideastruct->arraysize,&systemerror);
    #####: 2303:if(systemerror)
        -: 2304:{
    #####: 2305:	ReportError(errorcontext,systemerror);
    #####: 2306:	FreeMemory((farvoid *)plain1,&systemerror);
    #####: 2307:	ErrorExit();
        -: 2308:}
        -: 2309:
    #####: 2310:plain2=(faruchar *)AllocateMemory(locideastruct->arraysize,&systemerror);
    #####: 2311:if(systemerror)
        -: 2312:{
    #####: 2313:	ReportError(errorcontext,systemerror);
    #####: 2314:	FreeMemory((farvoid *)plain1,&systemerror);
    #####: 2315:	FreeMemory((farvoid *)crypt1,&systemerror);
    #####: 2316:	ErrorExit();
        -: 2317:}
        -: 2318:/*
        -: 2319:** Note that we build the "plaintext" by simply loading
        -: 2320:** the array up with random numbers.
        -: 2321:*/
    #####: 2322:for(i=0;i<locideastruct->arraysize;i++)
    #####: 2323:	plain1[i]=(uchar)(abs_randwc(255) & 0xFF);
        -: 2324:
        -: 2325:/*
        -: 2326:** See if we need to perform self adjustment loop.
        -: 2327:*/
    #####: 2328:if(locideastruct->adjust==0)
        -: 2329:{
        -: 2330:	/*
        -: 2331:	** Do self-adjustment.  This involves initializing the
        -: 2332:	** # of loops and increasing the loop count until we
        -: 2333:	** get a number of loops that we can use.
        -: 2334:	*/
    #####: 2335:	for(locideastruct->loops=100L;
    #####: 2336:	  locideastruct->loops<MAXIDEALOOPS;
    #####: 2337:	  locideastruct->loops+=10L)
    #####: 2338:		if(DoIDEAIteration(plain1,crypt1,plain2,
        -: 2339:		  locideastruct->arraysize,
        -: 2340:		  locideastruct->loops,
    #####: 2341:		  Z,DK)>global_min_ticks) break;
        -: 2342:}
        -: 2343:
        -: 2344:/*
        -: 2345:** All's well if we get here.  Do the test.
        -: 2346:*/
        -: 2347:accumtime=0L;
        -: 2348:iterations=(double)0.0;
        -: 2349:
        -: 2350:do {
    #####: 2351:	accumtime+=DoIDEAIteration(plain1,crypt1,plain2,
        -: 2352:		locideastruct->arraysize,
        -: 2353:		locideastruct->loops,Z,DK);
    #####: 2354:	iterations+=(double)locideastruct->loops;
    #####: 2355:} while(TicksToSecs(accumtime)<locideastruct->request_secs);
        -: 2356:
        -: 2357:/*
        -: 2358:** Clean up, calculate results, and go home.  Be sure to
        -: 2359:** show that we don't have to rerun adjustment code.
        -: 2360:*/
    #####: 2361:FreeMemory((farvoid *)plain1,&systemerror);
    #####: 2362:FreeMemory((farvoid *)crypt1,&systemerror);
    #####: 2363:FreeMemory((farvoid *)plain2,&systemerror);
    #####: 2364:locideastruct->iterspersec=iterations / TicksToFracSecs(accumtime);
        -: 2365:
    #####: 2366:if(locideastruct->adjust==0)
    #####: 2367:	locideastruct->adjust=1;
        -: 2368:
    #####: 2369:return;
        -: 2370:
        -: 2371:}
        -: 2372:
        -: 2373:/********************
        -: 2374:** DoIDEAIteration **
        -: 2375:*********************
        -: 2376:** Execute a single iteration of the IDEA encryption algorithm.
        -: 2377:** Actually, a single iteration is one encryption and one
        -: 2378:** decryption.
        -: 2379:*/
    #####: 2380:static ulong DoIDEAIteration(faruchar *plain1,
        -: 2381:			faruchar *crypt1,
        -: 2382:			faruchar *plain2,
        -: 2383:			ulong arraysize,
        -: 2384:			ulong nloops,
        -: 2385:			IDEAkey Z,
        -: 2386:			IDEAkey DK)
        -: 2387:{
        -: 2388:register ulong i;
        -: 2389:register ulong j;
        -: 2390:ulong elapsed;
        -: 2391:#ifdef DEBUG
        -: 2392:int status=0;
        -: 2393:#endif
        -: 2394:
        -: 2395:/*
        -: 2396:** Start the stopwatch.
        -: 2397:*/
    #####: 2398:elapsed=StartStopwatch();
        -: 2399:
        -: 2400:/*
        -: 2401:** Do everything for nloops.
        -: 2402:*/
    #####: 2403:for(i=0;i<nloops;i++)
        -: 2404:{
    #####: 2405:	for(j=0;j<arraysize;j+=(sizeof(u16)*4))
    #####: 2406:		cipher_idea((u16 *)(plain1+j),(u16 *)(crypt1+j),Z);       /* Encrypt */
        -: 2407:
    #####: 2408:	for(j=0;j<arraysize;j+=(sizeof(u16)*4))
    #####: 2409:		cipher_idea((u16 *)(crypt1+j),(u16 *)(plain2+j),DK);      /* Decrypt */
        -: 2410:}
        -: 2411:
        -: 2412:#ifdef DEBUG
        -: 2413:for(j=0;j<arraysize;j++)
        -: 2414:	if(*(plain1+j)!=*(plain2+j)){
        -: 2415:		printf("IDEA Error! \n");
        -: 2416:                status=1;
        -: 2417:                }
        -: 2418:if (status==0) printf("IDEA: OK\n");
        -: 2419:#endif
        -: 2420:
        -: 2421:/*
        -: 2422:** Get elapsed time.
        -: 2423:*/
    #####: 2424:return(StopStopwatch(elapsed));
        -: 2425:}
        -: 2426:
        -: 2427:/********
        -: 2428:** mul **
        -: 2429:*********
        -: 2430:** Performs multiplication, modulo (2**16)+1.  This code is structured
        -: 2431:** on the assumption that untaken branches are cheaper than taken
        -: 2432:** branches, and that the compiler doesn't schedule branches.
        -: 2433:*/
        -: 2434:static u16 mul(register u16 a, register u16 b)
        -: 2435:{
        -: 2436:register u32 p;
    #####: 2437:if(a)
    #####: 2438:{       if(b)
    #####: 2439:	{       p=(u32)(a*b);
    #####: 2440:		b=low16(p);
    #####: 2441:		a=(u16)(p>>16);
    #####: 2442:		return(b-a+(b<a));
        -: 2443:	}
        -: 2444:	else
    #####: 2445:		return(1-a);
        -: 2446:}
        -: 2447:else
    #####: 2448:	return(1-b);
        -: 2449:}
        -: 2450:
        -: 2451:/********
        -: 2452:** inv **
        -: 2453:*********
        -: 2454:** Compute multiplicative inverse of x, modulo (2**16)+1
        -: 2455:** using Euclid's GCD algorithm.  It is unrolled twice
        -: 2456:** to avoid swapping the meaning of the registers.  And
        -: 2457:** some subtracts are changed to adds.
        -: 2458:*/
    #####: 2459:static u16 inv(u16 x)
        -: 2460:{
        -: 2461:u16 t0, t1;
        -: 2462:u16 q, y;
        -: 2463:
    #####: 2464:if(x<=1)
        -: 2465:	return(x);      /* 0 and 1 are self-inverse */
    #####: 2466:t1=0x10001 / x;
    #####: 2467:y=0x10001 % x;
    #####: 2468:if(y==1)
    #####: 2469:	return(low16(1-t1));
        -: 2470:t0=1;
        -: 2471:do {
    #####: 2472:	q=x/y;
    #####: 2473:	x=x%y;
    #####: 2474:	t0+=q*t1;
    #####: 2475:	if(x==1) return(t0);
    #####: 2476:	q=y/x;
    #####: 2477:	y=y%x;
    #####: 2478:	t1+=q*t0;
    #####: 2479:} while(y!=1);
    #####: 2480:return(low16(1-t1));
        -: 2481:}
        -: 2482:
        -: 2483:/****************
        -: 2484:** en_key_idea **
        -: 2485:*****************
        -: 2486:** Compute IDEA encryption subkeys Z
        -: 2487:*/
    #####: 2488:static void en_key_idea(u16 *userkey, u16 *Z)
        -: 2489:{
        -: 2490:int i,j;
        -: 2491:
        -: 2492:/*
        -: 2493:** shifts
        -: 2494:*/
    #####: 2495:for(j=0;j<8;j++)
    #####: 2496:	Z[j]=*userkey++;
    #####: 2497:for(i=0;j<KEYLEN;j++)
    #####: 2498:{       i++;
    #####: 2499:	Z[i+7]=(Z[i&7]<<9)| (Z[(i+1) & 7] >> 7);
    #####: 2500:	Z+=i&8;
    #####: 2501:	i&=7;
        -: 2502:}
    #####: 2503:return;
        -: 2504:}
        -: 2505:
        -: 2506:/****************
        -: 2507:** de_key_idea **
        -: 2508:*****************
        -: 2509:** Compute IDEA decryption subkeys DK from encryption
        -: 2510:** subkeys Z.
        -: 2511:*/
    #####: 2512:static void de_key_idea(IDEAkey Z, IDEAkey DK)
        -: 2513:{
        -: 2514:IDEAkey TT;
        -: 2515:int j;
        -: 2516:u16 t1, t2, t3;
        -: 2517:u16 *p;
    #####: 2518:p=(u16 *)(TT+KEYLEN);
        -: 2519:
    #####: 2520:t1=inv(*Z++);
    #####: 2521:t2=-*Z++;
    #####: 2522:t3=-*Z++;
    #####: 2523:*--p=inv(*Z++);
    #####: 2524:*--p=t3;
    #####: 2525:*--p=t2;
    #####: 2526:*--p=t1;
        -: 2527:
    #####: 2528:for(j=1;j<ROUNDS;j++)
    #####: 2529:{       t1=*Z++;
    #####: 2530:	*--p=*Z++;
    #####: 2531:	*--p=t1;
    #####: 2532:	t1=inv(*Z++);
    #####: 2533:	t2=-*Z++;
    #####: 2534:	t3=-*Z++;
    #####: 2535:	*--p=inv(*Z++);
    #####: 2536:	*--p=t2;
    #####: 2537:	*--p=t3;
    #####: 2538:	*--p=t1;
        -: 2539:}
    #####: 2540:t1=*Z++;
    #####: 2541:*--p=*Z++;
    #####: 2542:*--p=t1;
    #####: 2543:t1=inv(*Z++);
    #####: 2544:t2=-*Z++;
    #####: 2545:t3=-*Z++;
    #####: 2546:*--p=inv(*Z++);
    #####: 2547:*--p=t3;
    #####: 2548:*--p=t2;
    #####: 2549:*--p=t1;
        -: 2550:/*
        -: 2551:** Copy and destroy temp copy
        -: 2552:*/
    #####: 2553:for(j=0,p=TT;j<KEYLEN;j++)
    #####: 2554:{       *DK++=*p;
    #####: 2555:	*p++=0;
        -: 2556:}
        -: 2557:
    #####: 2558:return;
        -: 2559:}
        -: 2560:
        -: 2561:/*
        -: 2562:** MUL(x,y)
        -: 2563:** This #define creates a macro that computes x=x*y modulo 0x10001.
        -: 2564:** Requires temps t16 and t32.  Also requires y to be strictly 16
        -: 2565:** bits.  Here, I am using the simplest form.  May not be the
        -: 2566:** fastest. -- RG
        -: 2567:*/
        -: 2568:/* #define MUL(x,y) (x=mul(low16(x),y)) */
        -: 2569:
        -: 2570:/****************
        -: 2571:** cipher_idea **
        -: 2572:*****************
        -: 2573:** IDEA encryption/decryption algorithm.
        -: 2574:*/
    #####: 2575:static void cipher_idea(u16 in[4],
        -: 2576:		u16 out[4],
        -: 2577:		register IDEAkey Z)
        -: 2578:{
        -: 2579:register u16 x1, x2, x3, x4, t1, t2;
        -: 2580:/* register u16 t16;
        -: 2581:register u16 t32; */
    #####: 2582:int r=ROUNDS;
        -: 2583:
    #####: 2584:x1=*in++;
    #####: 2585:x2=*in++;
    #####: 2586:x3=*in++;
    #####: 2587:x4=*in;
        -: 2588:
        -: 2589:do {
    #####: 2590:	MUL(x1,*Z++);
    #####: 2591:	x2+=*Z++;
    #####: 2592:	x3+=*Z++;
    #####: 2593:	MUL(x4,*Z++);
        -: 2594:
    #####: 2595:	t2=x1^x3;
    #####: 2596:	MUL(t2,*Z++);
    #####: 2597:	t1=t2+(x2^x4);
    #####: 2598:	MUL(t1,*Z++);
    #####: 2599:	t2=t1+t2;
        -: 2600:
    #####: 2601:	x1^=t1;
    #####: 2602:	x4^=t2;
        -: 2603:
    #####: 2604:	t2^=x2;
    #####: 2605:	x2=x3^t1;
    #####: 2606:	x3=t2;
    #####: 2607:} while(--r);
    #####: 2608:MUL(x1,*Z++);
    #####: 2609:*out++=x1;
    #####: 2610:*out++=x3+*Z++;
    #####: 2611:*out++=x2+*Z++;
    #####: 2612:MUL(x4,*Z);
    #####: 2613:*out=x4;
    #####: 2614:return;
        -: 2615:}
        -: 2616:
        -: 2617:/************************
        -: 2618:** HUFFMAN COMPRESSION **
        -: 2619:************************/
        -: 2620:
        -: 2621:/**************
        -: 2622:** DoHuffman **
        -: 2623:***************
        -: 2624:** Execute a huffman compression on a block of plaintext.
        -: 2625:** Note that (as with IDEA encryption) an iteration of the
        -: 2626:** Huffman test includes a compression AND a decompression.
        -: 2627:** Also, the compression cycle includes building the
        -: 2628:** Huffman tree.
        -: 2629:*/
    #####: 2630:void DoHuffman(void)
        -: 2631:{
        -: 2632:HuffStruct *lochuffstruct;      /* Loc pointer to global data */
        -: 2633:char *errorcontext;
        -: 2634:int systemerror;
        -: 2635:ulong accumtime;
        -: 2636:double iterations;
        -: 2637:farchar *comparray;
        -: 2638:farchar *decomparray;
        -: 2639:farchar *plaintext;
        -: 2640:
        -: 2641:/*
        -: 2642:** Link to global data
        -: 2643:*/
    #####: 2644:lochuffstruct=&global_huffstruct;
        -: 2645:
        -: 2646:/*
        -: 2647:** Set error context.
        -: 2648:*/
    #####: 2649:errorcontext="CPU:Huffman";
        -: 2650:
        -: 2651:/*
        -: 2652:** Allocate memory for the plaintext and the compressed text.
        -: 2653:** We'll be really pessimistic here, and allocate equal amounts
        -: 2654:** for both (though we know...well, we PRESUME) the compressed
        -: 2655:** stuff will take less than the plain stuff.
        -: 2656:** Also note that we'll build a 3rd buffer to decompress
        -: 2657:** into, and we preallocate space for the huffman tree.
        -: 2658:** (We presume that the Huffman tree will grow no larger
        -: 2659:** than 512 bytes.  This is actually a super-conservative
        -: 2660:** estimate...but, who cares?)
        -: 2661:*/
    #####: 2662:plaintext=(farchar *)AllocateMemory(lochuffstruct->arraysize,&systemerror);
    #####: 2663:if(systemerror)
    #####: 2664:{       ReportError(errorcontext,systemerror);
    #####: 2665:	ErrorExit();
        -: 2666:}
    #####: 2667:comparray=(farchar *)AllocateMemory(lochuffstruct->arraysize,&systemerror);
    #####: 2668:if(systemerror)
    #####: 2669:{       ReportError(errorcontext,systemerror);
    #####: 2670:	FreeMemory(plaintext,&systemerror);
    #####: 2671:	ErrorExit();
        -: 2672:}
    #####: 2673:decomparray=(farchar *)AllocateMemory(lochuffstruct->arraysize,&systemerror);
    #####: 2674:if(systemerror)
    #####: 2675:{       ReportError(errorcontext,systemerror);
    #####: 2676:	FreeMemory(plaintext,&systemerror);
    #####: 2677:	FreeMemory(comparray,&systemerror);
    #####: 2678:	ErrorExit();
        -: 2679:}
        -: 2680:
    #####: 2681:hufftree=(huff_node *)AllocateMemory(sizeof(huff_node) * 512,
        -: 2682:	&systemerror);
    #####: 2683:if(systemerror)
    #####: 2684:{       ReportError(errorcontext,systemerror);
    #####: 2685:	FreeMemory(plaintext,&systemerror);
    #####: 2686:	FreeMemory(comparray,&systemerror);
    #####: 2687:	FreeMemory(decomparray,&systemerror);
    #####: 2688:	ErrorExit();
        -: 2689:}
        -: 2690:
        -: 2691:/*
        -: 2692:** Build the plaintext buffer.  Since we want this to
        -: 2693:** actually be able to compress, we'll use the
        -: 2694:** wordcatalog to build the plaintext stuff.
        -: 2695:*/
        -: 2696:/*
        -: 2697:** Reset random number generator so things repeat.
        -: 2698:** added by Uwe F. Mayer
        -: 2699:*/
    #####: 2700:randnum((int32)13);
    #####: 2701:create_text_block(plaintext,lochuffstruct->arraysize-1,(ushort)500);
    #####: 2702:plaintext[lochuffstruct->arraysize-1L]='\0';
    #####: 2703:plaintextlen=lochuffstruct->arraysize;
        -: 2704:
        -: 2705:/*
        -: 2706:** See if we need to perform self adjustment loop.
        -: 2707:*/
    #####: 2708:if(lochuffstruct->adjust==0)
        -: 2709:{
        -: 2710:	/*
        -: 2711:	** Do self-adjustment.  This involves initializing the
        -: 2712:	** # of loops and increasing the loop count until we
        -: 2713:	** get a number of loops that we can use.
        -: 2714:	*/
    #####: 2715:	for(lochuffstruct->loops=100L;
    #####: 2716:	  lochuffstruct->loops<MAXHUFFLOOPS;
    #####: 2717:	  lochuffstruct->loops+=10L)
    #####: 2718:		if(DoHuffIteration(plaintext,
        -: 2719:			comparray,
        -: 2720:			decomparray,
        -: 2721:		  lochuffstruct->arraysize,
        -: 2722:		  lochuffstruct->loops,
    #####: 2723:		  hufftree)>global_min_ticks) break;
        -: 2724:}
        -: 2725:
        -: 2726:/*
        -: 2727:** All's well if we get here.  Do the test.
        -: 2728:*/
        -: 2729:accumtime=0L;
        -: 2730:iterations=(double)0.0;
        -: 2731:
        -: 2732:do {
    #####: 2733:	accumtime+=DoHuffIteration(plaintext,
        -: 2734:		comparray,
        -: 2735:		decomparray,
        -: 2736:		lochuffstruct->arraysize,
        -: 2737:		lochuffstruct->loops,
        -: 2738:		hufftree);
    #####: 2739:	iterations+=(double)lochuffstruct->loops;
    #####: 2740:} while(TicksToSecs(accumtime)<lochuffstruct->request_secs);
        -: 2741:
        -: 2742:/*
        -: 2743:** Clean up, calculate results, and go home.  Be sure to
        -: 2744:** show that we don't have to rerun adjustment code.
        -: 2745:*/
    #####: 2746:FreeMemory((farvoid *)plaintext,&systemerror);
    #####: 2747:FreeMemory((farvoid *)comparray,&systemerror);
    #####: 2748:FreeMemory((farvoid *)decomparray,&systemerror);
    #####: 2749:FreeMemory((farvoid *)hufftree,&systemerror);
    #####: 2750:lochuffstruct->iterspersec=iterations / TicksToFracSecs(accumtime);
        -: 2751:
    #####: 2752:if(lochuffstruct->adjust==0)
    #####: 2753:	lochuffstruct->adjust=1;
        -: 2754:
    #####: 2755:}
        -: 2756:
        -: 2757:/*********************
        -: 2758:** create_text_line **
        -: 2759:**********************
        -: 2760:** Create a random line of text, stored at *dt.  The line may be
        -: 2761:** no more than nchars long.
        -: 2762:*/
    #####: 2763:static void create_text_line(farchar *dt,
        -: 2764:			long nchars)
        -: 2765:{
        -: 2766:long charssofar;        /* # of characters so far */
        -: 2767:long tomove;            /* # of characters to move */
        -: 2768:char myword[40];        /* Local buffer for words */
        -: 2769:farchar *wordptr;       /* Pointer to word from catalog */
        -: 2770:
    #####: 2771:charssofar=0;
        -: 2772:
        -: 2773:do {
        -: 2774:/*
        -: 2775:** Grab a random word from the wordcatalog
        -: 2776:*/
        -: 2777:/* wordptr=wordcatarray[abs_randwc((long)WORDCATSIZE)];*/
    #####: 2778:wordptr=wordcatarray[abs_randwc((int32)WORDCATSIZE)];
    #####: 2779:MoveMemory((farvoid *)myword,
        -: 2780:	(farvoid *)wordptr,
    #####: 2781:	(unsigned long)strlen(wordptr)+1);
        -: 2782:
        -: 2783:/*
        -: 2784:** Append a blank.
        -: 2785:*/
    #####: 2786:tomove=strlen(myword)+1;
    #####: 2787:myword[tomove-1]=' ';
        -: 2788:
        -: 2789:/*
        -: 2790:** See how long it is.  If its length+charssofar > nchars, we have
        -: 2791:** to trim it.
        -: 2792:*/
    #####: 2793:if((tomove+charssofar)>nchars)
    #####: 2794:	tomove=nchars-charssofar;
        -: 2795:/*
        -: 2796:** Attach the word to the current line.  Increment counter.
        -: 2797:*/
    #####: 2798:MoveMemory((farvoid *)dt,(farvoid *)myword,(unsigned long)tomove);
    #####: 2799:charssofar+=tomove;
    #####: 2800:dt+=tomove;
        -: 2801:
        -: 2802:/*
        -: 2803:** If we're done, bail out.  Otherwise, go get another word.
        -: 2804:*/
    #####: 2805:} while(charssofar<nchars);
        -: 2806:
    #####: 2807:return;
        -: 2808:}
        -: 2809:
        -: 2810:/**********************
        -: 2811:** create_text_block **
        -: 2812:***********************
        -: 2813:** Build a block of text randomly loaded with words.  The words
        -: 2814:** come from the wordcatalog (which must be loaded before you
        -: 2815:** call this).
        -: 2816:** *tb points to the memory where the text is to be built.
        -: 2817:** tblen is the # of bytes to put into the text block
        -: 2818:** maxlinlen is the maximum length of any line (line end indicated
        -: 2819:**  by a carriage return).
        -: 2820:*/
    #####: 2821:static void create_text_block(farchar *tb,
        -: 2822:			ulong tblen,
        -: 2823:			ushort maxlinlen)
        -: 2824:{
        -: 2825:ulong bytessofar;       /* # of bytes so far */
        -: 2826:ulong linelen;          /* Line length */
        -: 2827:
    #####: 2828:bytessofar=0L;
        -: 2829:do {
        -: 2830:
        -: 2831:/*
        -: 2832:** Pick a random length for a line and fill the line.
        -: 2833:** Make sure the line can fit (haven't exceeded tablen) and also
        -: 2834:** make sure you leave room to append a carriage return.
        -: 2835:*/
    #####: 2836:linelen=abs_randwc(maxlinlen-6)+6;
    #####: 2837:if((linelen+bytessofar)>tblen)
    #####: 2838:	linelen=tblen-bytessofar;
        -: 2839:
    #####: 2840:if(linelen>1)
        -: 2841:{
    #####: 2842:	create_text_line(tb,linelen);
        -: 2843:}
    #####: 2844:tb+=linelen-1;          /* Add the carriage return */
    #####: 2845:*tb++='\n';
        -: 2846:
    #####: 2847:bytessofar+=linelen;
        -: 2848:
    #####: 2849:} while(bytessofar<tblen);
        -: 2850:
    #####: 2851:}
        -: 2852:
        -: 2853:/********************
        -: 2854:** DoHuffIteration **
        -: 2855:*********************
        -: 2856:** Perform the huffman benchmark.  This routine
        -: 2857:**  (a) Builds the huffman tree
        -: 2858:**  (b) Compresses the text
        -: 2859:**  (c) Decompresses the text and verifies correct decompression
        -: 2860:*/
    #####: 2861:static ulong DoHuffIteration(farchar *plaintext,
        -: 2862:	farchar *comparray,
        -: 2863:	farchar *decomparray,
        -: 2864:	ulong arraysize,
        -: 2865:	ulong nloops,
        -: 2866:	huff_node *hufftree)
        -: 2867:{
        -: 2868:int i;                          /* Index */
        -: 2869:long j;                         /* Bigger index */
        -: 2870:int root;                       /* Pointer to huffman tree root */
        -: 2871:float lowfreq1, lowfreq2;       /* Low frequency counters */
        -: 2872:int lowidx1, lowidx2;           /* Indexes of low freq. elements */
        -: 2873:long bitoffset;                 /* Bit offset into text */
        -: 2874:long textoffset;                /* Char offset into text */
        -: 2875:long maxbitoffset;              /* Holds limit of bit offset */
        -: 2876:long bitstringlen;              /* Length of bitstring */
        -: 2877:int c;                          /* Character from plaintext */
        -: 2878:char bitstring[30];             /* Holds bitstring */
        -: 2879:ulong elapsed;                  /* For stopwatch */
        -: 2880:#ifdef DEBUG
        -: 2881:int status=0;
        -: 2882:#endif
        -: 2883:
        -: 2884:/*
        -: 2885:** Start the stopwatch
        -: 2886:*/
    #####: 2887:elapsed=StartStopwatch();
        -: 2888:
        -: 2889:/*
        -: 2890:** Do everything for nloops
        -: 2891:*/
    #####: 2892:while(nloops--)
        -: 2893:{
        -: 2894:
        -: 2895:/*
        -: 2896:** Calculate the frequency of each byte value. Store the
        -: 2897:** results in what will become the "leaves" of the
        -: 2898:** Huffman tree.  Interior nodes will be built in those
        -: 2899:** nodes greater than node #255.
        -: 2900:*/
    #####: 2901:for(i=0;i<256;i++)
        -: 2902:{
    #####: 2903:	hufftree[i].freq=(float)0.0;
    #####: 2904:	hufftree[i].c=(unsigned char)i;
        -: 2905:}
        -: 2906:
    #####: 2907:for(j=0;j<arraysize;j++)
    #####: 2908:	hufftree[(int)plaintext[j]].freq+=(float)1.0;
        -: 2909:
    #####: 2910:for(i=0;i<256;i++)
    #####: 2911:	if(hufftree[i].freq != (float)0.0)
    #####: 2912:		hufftree[i].freq/=(float)arraysize;
        -: 2913:
        -: 2914:/* Reset the second half of the tree. Otherwise the loop below that
        -: 2915:** compares the frequencies up to index 512 makes no sense. Some
        -: 2916:** systems automatically zero out memory upon allocation, others (like
        -: 2917:** for example DEC Unix) do not. Depending on this the loop below gets
        -: 2918:** different data and different run times. On our alpha the data that
        -: 2919:** was arbitrarily assigned led to an underflow error at runtime. We
        -: 2920:** use that zeroed-out bits are in fact 0 as a float.
        -: 2921:** Uwe F. Mayer */
    #####: 2922:bzero((char *)&(hufftree[256]),sizeof(huff_node)*256);
        -: 2923:/*
        -: 2924:** Build the huffman tree.  First clear all the parent
        -: 2925:** pointers and left/right pointers.  Also, discard all
        -: 2926:** nodes that have a frequency of true 0.  */
    #####: 2927:for(i=0;i<512;i++)
    #####: 2928:{       if(hufftree[i].freq==(float)0.0)
    #####: 2929:		hufftree[i].parent=EXCLUDED;
        -: 2930:	else
    #####: 2931:		hufftree[i].parent=hufftree[i].left=hufftree[i].right=-1;
        -: 2932:}
        -: 2933:
        -: 2934:/*
        -: 2935:** Go through the tree. Finding nodes of really low
        -: 2936:** frequency.
        -: 2937:*/
        -: 2938:root=255;                       /* Starting root node-1 */
        -: 2939:while(1)
        -: 2940:{
    #####: 2941:	lowfreq1=(float)2.0; lowfreq2=(float)2.0;
    #####: 2942:	lowidx1=-1; lowidx2=-1;
        -: 2943:	/*
        -: 2944:	** Find first lowest frequency.
        -: 2945:	*/
    #####: 2946:	for(i=0;i<=root;i++)
    #####: 2947:		if(hufftree[i].parent<0)
    #####: 2948:			if(hufftree[i].freq<lowfreq1)
    #####: 2949:			{       lowfreq1=hufftree[i].freq;
    #####: 2950:				lowidx1=i;
        -: 2951:			}
        -: 2952:
        -: 2953:	/*
        -: 2954:	** Did we find a lowest value?  If not, the
        -: 2955:	** tree is done.
        -: 2956:	*/
    #####: 2957:	if(lowidx1==-1) break;
        -: 2958:
        -: 2959:	/*
        -: 2960:	** Find next lowest frequency
        -: 2961:	*/
    #####: 2962:	for(i=0;i<=root;i++)
    #####: 2963:		if((hufftree[i].parent<0) && (i!=lowidx1))
    #####: 2964:			if(hufftree[i].freq<lowfreq2)
    #####: 2965:			{       lowfreq2=hufftree[i].freq;
    #####: 2966:				lowidx2=i;
        -: 2967:			}
        -: 2968:
        -: 2969:	/*
        -: 2970:	** If we could only find one item, then that
        -: 2971:	** item is surely the root, and (as above) the
        -: 2972:	** tree is done.
        -: 2973:	*/
    #####: 2974:	if(lowidx2==-1) break;
        -: 2975:
        -: 2976:	/*
        -: 2977:	** Attach the two new nodes to the current root, and
        -: 2978:	** advance the current root.
        -: 2979:	*/
    #####: 2980:	root++;                 /* New root */
    #####: 2981:	hufftree[lowidx1].parent=root;
    #####: 2982:	hufftree[lowidx2].parent=root;
    #####: 2983:	hufftree[root].freq=lowfreq1+lowfreq2;
    #####: 2984:	hufftree[root].left=lowidx1;
    #####: 2985:	hufftree[root].right=lowidx2;
    #####: 2986:	hufftree[root].parent=-2;       /* Show root */
        -: 2987:}
        -: 2988:
        -: 2989:/*
        -: 2990:** Huffman tree built...compress the plaintext
        -: 2991:*/
        -: 2992:bitoffset=0L;                           /* Initialize bit offset */
    #####: 2993:for(i=0;i<arraysize;i++)
        -: 2994:{
    #####: 2995:	c=(int)plaintext[i];                 /* Fetch character */
        -: 2996:	/*
        -: 2997:	** Build a bit string for byte c
        -: 2998:	*/
    #####: 2999:	bitstringlen=0;
    #####: 3000:	while(hufftree[c].parent!=-2)
    #####: 3001:	{       if(hufftree[hufftree[c].parent].left==c)
    #####: 3002:			bitstring[bitstringlen]='0';
        -: 3003:		else
    #####: 3004:			bitstring[bitstringlen]='1';
    #####: 3005:		c=hufftree[c].parent;
    #####: 3006:		bitstringlen++;
        -: 3007:	}
        -: 3008:
        -: 3009:	/*
        -: 3010:	** Step backwards through the bit string, setting
        -: 3011:	** bits in the compressed array as you go.
        -: 3012:	*/
    #####: 3013:	while(bitstringlen--)
    #####: 3014:	{       SetCompBit((u8 *)comparray,(u32)bitoffset,bitstring[bitstringlen]);
    #####: 3015:		bitoffset++;
        -: 3016:	}
        -: 3017:}
        -: 3018:
        -: 3019:/*
        -: 3020:** Compression done.  Perform de-compression.
        -: 3021:*/
        -: 3022:maxbitoffset=bitoffset;
        -: 3023:bitoffset=0;
        -: 3024:textoffset=0;
        -: 3025:do {
    #####: 3026:	i=root;
    #####: 3027:	while(hufftree[i].left!=-1)
    #####: 3028:	{       if(GetCompBit((u8 *)comparray,(u32)bitoffset)==0)
        -: 3029:			i=hufftree[i].left;
        -: 3030:		else
    #####: 3031:			i=hufftree[i].right;
    #####: 3032:		bitoffset++;
        -: 3033:	}
    #####: 3034:	decomparray[textoffset]=hufftree[i].c;
        -: 3035:
        -: 3036:#ifdef DEBUG
        -: 3037:	if(hufftree[i].c != plaintext[textoffset])
        -: 3038:	{
        -: 3039:		/* Show error */
        -: 3040:		printf("Error at textoffset %ld\n",textoffset);
        -: 3041:		status=1;
        -: 3042:	}
        -: 3043:#endif
    #####: 3044:	textoffset++;
    #####: 3045:} while(bitoffset<maxbitoffset);
        -: 3046:
        -: 3047:}       /* End the big while(nloops--) from above */
        -: 3048:
        -: 3049:/*
        -: 3050:** All done
        -: 3051:*/
        -: 3052:#ifdef DEBUG
        -: 3053:  if (status==0) printf("Huffman: OK\n");
        -: 3054:#endif
    #####: 3055:return(StopStopwatch(elapsed));
        -: 3056:}
        -: 3057:
        -: 3058:/***************
        -: 3059:** SetCompBit **
        -: 3060:****************
        -: 3061:** Set a bit in the compression array.  The value of the
        -: 3062:** bit is set according to char bitchar.
        -: 3063:*/
        -: 3064:static void SetCompBit(u8 *comparray,
        -: 3065:		u32 bitoffset,
        -: 3066:		char bitchar)
        -: 3067:{
        -: 3068:u32 byteoffset;
        -: 3069:int bitnumb;
        -: 3070:
        -: 3071:/*
        -: 3072:** First calculate which element in the comparray to
        -: 3073:** alter. and the bitnumber.
        -: 3074:*/
    #####: 3075:byteoffset=bitoffset>>3;
    #####: 3076:bitnumb=bitoffset % 8;
        -: 3077:
        -: 3078:/*
        -: 3079:** Set or clear
        -: 3080:*/
    #####: 3081:if(bitchar=='1')
    #####: 3082:	comparray[byteoffset]|=(1<<bitnumb);
        -: 3083:else
    #####: 3084:	comparray[byteoffset]&=~(1<<bitnumb);
        -: 3085:
        -: 3086:return;
        -: 3087:}
        -: 3088:
        -: 3089:/***************
        -: 3090:** GetCompBit **
        -: 3091:****************
        -: 3092:** Return the bit value of a bit in the comparession array.
        -: 3093:** Returns 0 if the bit is clear, nonzero otherwise.
        -: 3094:*/
        -: 3095:static int GetCompBit(u8 *comparray,
        -: 3096:		u32 bitoffset)
        -: 3097:{
        -: 3098:u32 byteoffset;
        -: 3099:int bitnumb;
        -: 3100:
        -: 3101:/*
        -: 3102:** Calculate byte offset and bit number.
        -: 3103:*/
    #####: 3104:byteoffset=bitoffset>>3;
    #####: 3105:bitnumb=bitoffset % 8;
        -: 3106:
        -: 3107:/*
        -: 3108:** Fetch
        -: 3109:*/
    #####: 3110:return((1<<bitnumb) & comparray[byteoffset] );
        -: 3111:}
        -: 3112:
        -: 3113:/********************************
        -: 3114:** BACK PROPAGATION NEURAL NET **
        -: 3115:*********************************
        -: 3116:** This code is a modified version of the code
        -: 3117:** that was submitted to BYTE Magazine by
        -: 3118:** Maureen Caudill.  It accomanied an article
        -: 3119:** that I CANNOT NOW RECALL.
        -: 3120:** The author's original heading/comment was
        -: 3121:** as follows:
        -: 3122:**
        -: 3123:**  Backpropagation Network
        -: 3124:**  Written by Maureen Caudill
        -: 3125:**  in Think C 4.0 on a Macintosh
        -: 3126:**
        -: 3127:**  (c) Maureen Caudill 1988-1991
        -: 3128:**  This network will accept 5x7 input patterns
        -: 3129:**  and produce 8 bit output patterns.
        -: 3130:**  The source code may be copied or modified without restriction,
        -: 3131:**  but no fee may be charged for its use.
        -: 3132:**
        -: 3133:** ++++++++++++++
        -: 3134:** I have modified the code so that it will work
        -: 3135:** on systems other than a Macintosh -- RG
        -: 3136:*/
        -: 3137:
        -: 3138:/***********
        -: 3139:** DoNNet **
        -: 3140:************
        -: 3141:** Perform the neural net benchmark.
        -: 3142:** Note that this benchmark is one of the few that
        -: 3143:** requires an input file.  That file is "NNET.DAT" and
        -: 3144:** should be on the local directory (from which the
        -: 3145:** benchmark program in launched).
        -: 3146:*/
        1: 3147:void DoNNET(void)
        -: 3148:{
        -: 3149:NNetStruct *locnnetstruct;      /* Local ptr to global data */
        -: 3150:char *errorcontext;
        -: 3151:ulong accumtime;
        -: 3152:double iterations;
        -: 3153:
        -: 3154:/*
        -: 3155:** Link to global data
        -: 3156:*/
        1: 3157:locnnetstruct=&global_nnetstruct;
        -: 3158:
        -: 3159:/*
        -: 3160:** Set error context
        -: 3161:*/
        1: 3162:errorcontext="CPU:NNET";
        -: 3163:
        -: 3164:/*
        -: 3165:** Init random number generator.
        -: 3166:** NOTE: It is important that the random number generator
        -: 3167:**  be re-initialized for every pass through this test.
        -: 3168:**  The NNET algorithm uses the random number generator
        -: 3169:**  to initialize the net.  Results are sensitive to
        -: 3170:**  the initial neural net state.
        -: 3171:*/
        -: 3172:/* randnum(3L); */
        1: 3173:randnum((int32)3);
        -: 3174:
        -: 3175:/*
        -: 3176:** Read in the input and output patterns.  We'll do this
        -: 3177:** only once here at the beginning.  These values don't
        -: 3178:** change once loaded.
        -: 3179:*/
        1: 3180:if(read_data_file()!=0)
    #####: 3181:   ErrorExit();
        -: 3182:
        -: 3183:
        -: 3184:/*
        -: 3185:** See if we need to perform self adjustment loop.
        -: 3186:*/
        1: 3187:if(locnnetstruct->adjust==0)
        -: 3188:{
        -: 3189:	/*
        -: 3190:	** Do self-adjustment.  This involves initializing the
        -: 3191:	** # of loops and increasing the loop count until we
        -: 3192:	** get a number of loops that we can use.
        -: 3193:	*/
        2: 3194:	for(locnnetstruct->loops=1L;
        1: 3195:	  locnnetstruct->loops<MAXNNETLOOPS;
    #####: 3196:	  locnnetstruct->loops++)
        -: 3197:	  {     /*randnum(3L); */
        1: 3198:		randnum((int32)3);
        2: 3199:		if(DoNNetIteration(locnnetstruct->loops)
        1: 3200:			>global_min_ticks) break;
        -: 3201:	  }
        -: 3202:}
        -: 3203:
        -: 3204:/*
        -: 3205:** All's well if we get here.  Do the test.
        -: 3206:*/
        -: 3207:accumtime=0L;
        -: 3208:iterations=(double)0.0;
        -: 3209:
        -: 3210:do {
        -: 3211:	/* randnum(3L); */    /* Gotta do this for Neural Net */
      434: 3212:	randnum((int32)3);    /* Gotta do this for Neural Net */
      434: 3213:	accumtime+=DoNNetIteration(locnnetstruct->loops);
      434: 3214:	iterations+=(double)locnnetstruct->loops;
      434: 3215:} while(TicksToSecs(accumtime)<locnnetstruct->request_secs);
        -: 3216:
        -: 3217:/*
        -: 3218:** Clean up, calculate results, and go home.  Be sure to
        -: 3219:** show that we don't have to rerun adjustment code.
        -: 3220:*/
        1: 3221:locnnetstruct->iterspersec=iterations / TicksToFracSecs(accumtime);
        -: 3222:
        1: 3223:if(locnnetstruct->adjust==0)
        1: 3224:	locnnetstruct->adjust=1;
        -: 3225:
        -: 3226:
        1: 3227:return;
        -: 3228:}
        -: 3229:
        -: 3230:/********************
        -: 3231:** DoNNetIteration **
        -: 3232:*********************
        -: 3233:** Do a single iteration of the neural net benchmark.
        -: 3234:** By iteration, we mean a "learning" pass.
        -: 3235:*/
      435: 3236:static ulong DoNNetIteration(ulong nloops)
        -: 3237:{
        -: 3238:ulong elapsed;          /* Elapsed time */
        -: 3239:int patt;
        -: 3240:
        -: 3241:/*
        -: 3242:** Run nloops learning cycles.  Notice that, counted with
        -: 3243:** the learning cycle is the weight randomization and
        -: 3244:** zeroing of changes.  This should reduce clock jitter,
        -: 3245:** since we don't have to stop and start the clock for
        -: 3246:** each iteration.
        -: 3247:*/
      435: 3248:elapsed=StartStopwatch();
     1305: 3249:while(nloops--)
        -: 3250:{
      435: 3251:	randomize_wts();
      435: 3252:	zero_changes();
      435: 3253:	iteration_count=1;
      435: 3254:	learned = F;
      435: 3255:	numpasses = 0;
   340170: 3256:	while (learned == F)
        -: 3257:	{
  3393000: 3258:		for (patt=0; patt<numpats; patt++)
        -: 3259:		{
  3393000: 3260:			worst_error = 0.0;      /* reset this every pass through data */
  3393000: 3261:			move_wt_changes();      /* move last pass's wt changes to momentum array */
  3393000: 3262:			do_forward_pass(patt);
  3393000: 3263:			do_back_pass(patt);
  3393000: 3264:			iteration_count++;
        -: 3265:		}
   339300: 3266:		numpasses ++;
   339300: 3267:		learned = check_out_error();
        -: 3268:	}
        -: 3269:#ifdef DEBUG
        -: 3270:printf("Learned in %d passes\n",numpasses);
        -: 3271:#endif
        -: 3272:}
      435: 3273:return(StopStopwatch(elapsed));
        -: 3274:}
        -: 3275:
        -: 3276:/*************************
        -: 3277:** do_mid_forward(patt) **
        -: 3278:**************************
        -: 3279:** Process the middle layer's forward pass
        -: 3280:** The activation of middle layer's neurode is the weighted
        -: 3281:** sum of the inputs from the input pattern, with sigmoid
        -: 3282:** function applied to the inputs.
        -: 3283:**/
  3393000: 3284:static void  do_mid_forward(int patt)
        -: 3285:{
        -: 3286:double  sum;
        -: 3287:int     neurode, i;
        -: 3288:
 30537000: 3289:for (neurode=0;neurode<MID_SIZE; neurode++)
        -: 3290:{
        -: 3291:	sum = 0.0;
950040000: 3292:	for (i=0; i<IN_SIZE; i++)
        -: 3293:	{       /* compute weighted sum of input signals */
950040000: 3294:		sum += mid_wts[neurode][i]*in_pats[patt][i];
        -: 3295:	}
        -: 3296:	/*
        -: 3297:	** apply sigmoid function f(x) = 1/(1+exp(-x)) to weighted sum
        -: 3298:	*/
 27144000: 3299:	sum = 1.0/(1.0+exp(-sum));
 27144000: 3300:	mid_out[neurode] = sum;
        -: 3301:}
  3393000: 3302:return;
        -: 3303:}
        -: 3304:
        -: 3305:/*********************
        -: 3306:** do_out_forward() **
        -: 3307:**********************
        -: 3308:** process the forward pass through the output layer
        -: 3309:** The activation of the output layer is the weighted sum of
        -: 3310:** the inputs (outputs from middle layer), modified by the
        -: 3311:** sigmoid function.
        -: 3312:**/
  3393000: 3313:static void  do_out_forward()
        -: 3314:{
        -: 3315:double sum;
        -: 3316:int neurode, i;
        -: 3317:
 30537000: 3318:for (neurode=0; neurode<OUT_SIZE; neurode++)
        -: 3319:{
        -: 3320:	sum = 0.0;
217152000: 3321:	for (i=0; i<MID_SIZE; i++)
        -: 3322:	{       /*
        -: 3323:		** compute weighted sum of input signals
        -: 3324:		** from middle layer
        -: 3325:		*/
217152000: 3326:		sum += out_wts[neurode][i]*mid_out[i];
        -: 3327:	}
        -: 3328:	/*
        -: 3329:	** Apply f(x) = 1/(1+exp(-x)) to weighted input
        -: 3330:	*/
 27144000: 3331:	sum = 1.0/(1.0+exp(-sum));
 27144000: 3332:	out_out[neurode] = sum;
        -: 3333:}
  3393000: 3334:return;
        -: 3335:}
        -: 3336:
        -: 3337:/*************************
        -: 3338:** display_output(patt) **
        -: 3339:**************************
        -: 3340:** Display the actual output vs. the desired output of the
        -: 3341:** network.
        -: 3342:** Once the training is complete, and the "learned" flag set
        -: 3343:** to TRUE, then display_output sends its output to both
        -: 3344:** the screen and to a text output file.
        -: 3345:**
        -: 3346:** NOTE: This routine has been disabled in the benchmark
        -: 3347:** version. -- RG
        -: 3348:**/
        -: 3349:/*
        -: 3350:void  display_output(int patt)
        -: 3351:{
        -: 3352:int             i;
        -: 3353:
        -: 3354:	fprintf(outfile,"\n Iteration # %d",iteration_count);
        -: 3355:	fprintf(outfile,"\n Desired Output:  ");
        -: 3356:
        -: 3357:	for (i=0; i<OUT_SIZE; i++)
        -: 3358:	{
        -: 3359:		fprintf(outfile,"%6.3f  ",out_pats[patt][i]);
        -: 3360:	}
        -: 3361:	fprintf(outfile,"\n Actual Output:   ");
        -: 3362:
        -: 3363:	for (i=0; i<OUT_SIZE; i++)
        -: 3364:	{
        -: 3365:		fprintf(outfile,"%6.3f  ",out_out[i]);
        -: 3366:	}
        -: 3367:	fprintf(outfile,"\n");
        -: 3368:	return;
        -: 3369:}
        -: 3370:*/
        -: 3371:
        -: 3372:/**********************
        -: 3373:** do_forward_pass() **
        -: 3374:***********************
        -: 3375:** control function for the forward pass through the network
        -: 3376:** NOTE: I have disabled the call to display_output() in
        -: 3377:**  the benchmark version -- RG.
        -: 3378:**/
        -: 3379:static void  do_forward_pass(int patt)
        -: 3380:{
  3393000: 3381:do_mid_forward(patt);   /* process forward pass, middle layer */
  3393000: 3382:do_out_forward();       /* process forward pass, output layer */
        -: 3383:/* display_output(patt);        ** display results of forward pass */
        -: 3384:return;
        -: 3385:}
        -: 3386:
        -: 3387:/***********************
        -: 3388:** do_out_error(patt) **
        -: 3389:************************
        -: 3390:** Compute the error for the output layer neurodes.
        -: 3391:** This is simply Desired - Actual.
        -: 3392:**/
  3393000: 3393:static void do_out_error(int patt)
        -: 3394:{
        -: 3395:int neurode;
        -: 3396:double error,tot_error, sum;
        -: 3397:
  3393000: 3398:tot_error = 0.0;
  3393000: 3399:sum = 0.0;
 30537000: 3400:for (neurode=0; neurode<OUT_SIZE; neurode++)
        -: 3401:{
 27144000: 3402:	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
        -: 3403:	/*
        -: 3404:	** while we're here, also compute magnitude
        -: 3405:	** of total error and worst error in this pass.
        -: 3406:	** We use these to decide if we are done yet.
        -: 3407:	*/
 27144000: 3408:	error = out_error[neurode];
 27144000: 3409:	if (error <0.0)
        -: 3410:	{
 17982900: 3411:		sum += -error;
 17982900: 3412:		if (-error > tot_error)
  9278550: 3413:			tot_error = -error; /* worst error this pattern */
        -: 3414:	}
        -: 3415:	else
        -: 3416:	{
  9161100: 3417:		sum += error;
  9161100: 3418:		if (error > tot_error)
  3569175: 3419:			tot_error = error; /* worst error this pattern */
        -: 3420:	}
        -: 3421:}
  3393000: 3422:avg_out_error[patt] = sum/OUT_SIZE;
  3393000: 3423:tot_out_error[patt] = tot_error;
  3393000: 3424:return;
        -: 3425:}
        -: 3426:
        -: 3427:/***********************
        -: 3428:** worst_pass_error() **
        -: 3429:************************
        -: 3430:** Find the worst and average error in the pass and save it
        -: 3431:**/
        -: 3432:static void  worst_pass_error()
        -: 3433:{
        -: 3434:double error,sum;
        -: 3435:
        -: 3436:int i;
        -: 3437:
   339300: 3438:error = 0.0;
   339300: 3439:sum = 0.0;
  3732300: 3440:for (i=0; i<numpats; i++)
        -: 3441:{
  3393000: 3442:	if (tot_out_error[i] > error) error = tot_out_error[i];
  3393000: 3443:	sum += avg_out_error[i];
        -: 3444:}
   339300: 3445:worst_error = error;
   339300: 3446:average_error = sum/numpats;
        -: 3447:return;
        -: 3448:}
        -: 3449:
        -: 3450:/*******************
        -: 3451:** do_mid_error() **
        -: 3452:********************
        -: 3453:** Compute the error for the middle layer neurodes
        -: 3454:** This is based on the output errors computed above.
        -: 3455:** Note that the derivative of the sigmoid f(x) is
        -: 3456:**        f'(x) = f(x)(1 - f(x))
        -: 3457:** Recall that f(x) is merely the output of the middle
        -: 3458:** layer neurode on the forward pass.
        -: 3459:**/
        -: 3460:static void do_mid_error()
        -: 3461:{
        -: 3462:double sum;
        -: 3463:int neurode, i;
        -: 3464:
 30537000: 3465:for (neurode=0; neurode<MID_SIZE; neurode++)
        -: 3466:{
        -: 3467:	sum = 0.0;
217152000: 3468:	for (i=0; i<OUT_SIZE; i++)
217152000: 3469:		sum += out_wts[i][neurode]*out_error[i];
        -: 3470:
        -: 3471:	/*
        -: 3472:	** apply the derivative of the sigmoid here
        -: 3473:	** Because of the choice of sigmoid f(I), the derivative
        -: 3474:	** of the sigmoid is f'(I) = f(I)(1 - f(I))
        -: 3475:	*/
 27144000: 3476:	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
        -: 3477:}
        -: 3478:return;
        -: 3479:}
        -: 3480:
        -: 3481:/*********************
        -: 3482:** adjust_out_wts() **
        -: 3483:**********************
        -: 3484:** Adjust the weights of the output layer.  The error for
        -: 3485:** the output layer has been previously propagated back to
        -: 3486:** the middle layer.
        -: 3487:** Use the Delta Rule with momentum term to adjust the weights.
        -: 3488:**/
  3393000: 3489:static void adjust_out_wts()
        -: 3490:{
        -: 3491:int weight, neurode;
        -: 3492:double learn,delta,alph;
        -: 3493:
  3393000: 3494:learn = BETA;
  3393000: 3495:alph  = ALPHA;
 30537000: 3496:for (neurode=0; neurode<OUT_SIZE; neurode++)
        -: 3497:{
217152000: 3498:	for (weight=0; weight<MID_SIZE; weight++)
        -: 3499:	{
        -: 3500:		/* standard delta rule */
217152000: 3501:		delta = learn * out_error[neurode] * mid_out[weight];
        -: 3502:
        -: 3503:		/* now the momentum term */
217152000: 3504:		delta += alph * out_wt_change[neurode][weight];
217152000: 3505:		out_wts[neurode][weight] += delta;
        -: 3506:
        -: 3507:		/* keep track of this pass's cum wt changes for next pass's momentum */
217152000: 3508:		out_wt_cum_change[neurode][weight] += delta;
        -: 3509:	}
        -: 3510:}
  3393000: 3511:return;
        -: 3512:}
        -: 3513:
        -: 3514:/*************************
        -: 3515:** adjust_mid_wts(patt) **
        -: 3516:**************************
        -: 3517:** Adjust the middle layer weights using the previously computed
        -: 3518:** errors.
        -: 3519:** We use the Generalized Delta Rule with momentum term
        -: 3520:**/
  3393000: 3521:static void adjust_mid_wts(int patt)
        -: 3522:{
        -: 3523:int weight, neurode;
        -: 3524:double learn,alph,delta;
        -: 3525:
  3393000: 3526:learn = BETA;
  3393000: 3527:alph  = ALPHA;
 30537000: 3528:for (neurode=0; neurode<MID_SIZE; neurode++)
        -: 3529:{
950040000: 3530:	for (weight=0; weight<IN_SIZE; weight++)
        -: 3531:	{
        -: 3532:		/* first the basic delta rule */
950040000: 3533:		delta = learn * mid_error[neurode] * in_pats[patt][weight];
        -: 3534:
        -: 3535:		/* with the momentum term */
950040000: 3536:		delta += alph * mid_wt_change[neurode][weight];
950040000: 3537:		mid_wts[neurode][weight] += delta;
        -: 3538:
        -: 3539:		/* keep track of this pass's cum wt changes for next pass's momentum */
950040000: 3540:		mid_wt_cum_change[neurode][weight] += delta;
        -: 3541:	}
        -: 3542:}
  3393000: 3543:return;
        -: 3544:}
        -: 3545:
        -: 3546:/*******************
        -: 3547:** do_back_pass() **
        -: 3548:********************
        -: 3549:** Process the backward propagation of error through network.
        -: 3550:**/
  3393000: 3551:void  do_back_pass(int patt)
        -: 3552:{
        -: 3553:
  3393000: 3554:do_out_error(patt);
  3393000: 3555:do_mid_error();
  3393000: 3556:adjust_out_wts();
  3393000: 3557:adjust_mid_wts(patt);
        -: 3558:
  3393000: 3559:return;
        -: 3560:}
        -: 3561:
        -: 3562:
        -: 3563:/**********************
        -: 3564:** move_wt_changes() **
        -: 3565:***********************
        -: 3566:** Move the weight changes accumulated last pass into the wt-change
        -: 3567:** array for use by the momentum term in this pass. Also zero out
        -: 3568:** the accumulating arrays after the move.
        -: 3569:**/
  3393000: 3570:static void move_wt_changes()
        -: 3571:{
        -: 3572:int i,j;
        -: 3573:
 30537000: 3574:for (i = 0; i<MID_SIZE; i++)
950040000: 3575:	for (j = 0; j<IN_SIZE; j++)
        -: 3576:	{
950040000: 3577:		mid_wt_change[i][j] = mid_wt_cum_change[i][j];
        -: 3578:		/*
        -: 3579:		** Zero it out for next pass accumulation.
        -: 3580:		*/
950040000: 3581:		mid_wt_cum_change[i][j] = 0.0;
        -: 3582:	}
        -: 3583:
 27144000: 3584:for (i = 0; i<OUT_SIZE; i++)
217152000: 3585:	for (j=0; j<MID_SIZE; j++)
        -: 3586:	{
217152000: 3587:		out_wt_change[i][j] = out_wt_cum_change[i][j];
217152000: 3588:		out_wt_cum_change[i][j] = 0.0;
        -: 3589:	}
        -: 3590:
  3393000: 3591:return;
        -: 3592:}
        -: 3593:
        -: 3594:/**********************
        -: 3595:** check_out_error() **
        -: 3596:***********************
        -: 3597:** Check to see if the error in the output layer is below
        -: 3598:** MARGIN*OUT_SIZE for all output patterns.  If so, then
        -: 3599:** assume the network has learned acceptably well.  This
        -: 3600:** is simply an arbitrary measure of how well the network
        -: 3601:** has learned -- many other standards are possible.
        -: 3602:**/
   339300: 3603:static int check_out_error()
        -: 3604:{
        -: 3605:int result,i,error;
        -: 3606:
   339300: 3607:result  = T;
   339300: 3608:error   = F;
   339300: 3609:worst_pass_error();     /* identify the worst error in this pass */
        -: 3610:
        -: 3611:/*
        -: 3612:#ifdef DEBUG
        -: 3613:printf("\n Iteration # %d",iteration_count);
        -: 3614:#endif
        -: 3615:*/
  3732300: 3616:for (i=0; i<numpats; i++)
        -: 3617:{
        -: 3618:/*      printf("\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
        -: 3619:	  i+1,tot_out_error[i], avg_out_error[i]);
        -: 3620:	fprintf(outfile,
        -: 3621:	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
        -: 3622:	 i+1,tot_out_error[i]);
        -: 3623:*/
        -: 3624:
  3393000: 3625:	if (worst_error >= STOP) result = F;
  3393000: 3626:	if (tot_out_error[i] >= 16.0) error = T;
        -: 3627:}
        -: 3628:
   339300: 3629:if (error == T) result = ERR;
        -: 3630:
        -: 3631:
        -: 3632:#ifdef DEBUG
        -: 3633:/* printf("\n Error this pass thru data:   Worst: %8.3f; Average: %8.3f",
        -: 3634: worst_error,average_error);
        -: 3635:*/
        -: 3636:/* fprintf(outfile,
        -: 3637: "\n Error this pass thru data:   Worst: %8.3f; Average: %8.3f",
        -: 3638:  worst_error, average_error); */
        -: 3639:#endif
        -: 3640:
   339300: 3641:return(result);
        -: 3642:}
        -: 3643:
        -: 3644:
        -: 3645:/*******************
        -: 3646:** zero_changes() **
        -: 3647:********************
        -: 3648:** Zero out all the wt change arrays
        -: 3649:**/
      435: 3650:static void zero_changes()
        -: 3651:{
        -: 3652:int i,j;
        -: 3653:
     3915: 3654:for (i = 0; i<MID_SIZE; i++)
        -: 3655:{
   121800: 3656:	for (j=0; j<IN_SIZE; j++)
        -: 3657:	{
   121800: 3658:		mid_wt_change[i][j] = 0.0;
   121800: 3659:		mid_wt_cum_change[i][j] = 0.0;
        -: 3660:	}
        -: 3661:}
        -: 3662:
     3480: 3663:for (i = 0; i< OUT_SIZE; i++)
        -: 3664:{
    27840: 3665:	for (j=0; j<MID_SIZE; j++)
        -: 3666:	{
    27840: 3667:		out_wt_change[i][j] = 0.0;
    27840: 3668:		out_wt_cum_change[i][j] = 0.0;
        -: 3669:	}
        -: 3670:}
      435: 3671:return;
        -: 3672:}
        -: 3673:
        -: 3674:
        -: 3675:/********************
        -: 3676:** randomize_wts() **
        -: 3677:*********************
        -: 3678:** Intialize the weights in the middle and output layers to
        -: 3679:** random values between -0.25..+0.25
        -: 3680:** Function rand() returns a value between 0 and 32767.
        -: 3681:**
        -: 3682:** NOTE: Had to make alterations to how the random numbers were
        -: 3683:** created.  -- RG.
        -: 3684:**/
      435: 3685:static void randomize_wts()
        -: 3686:{
        -: 3687:int neurode,i;
        -: 3688:double value;
        -: 3689:
        -: 3690:/*
        -: 3691:** Following not used int benchmark version -- RG
        -: 3692:**
        -: 3693:**        printf("\n Please enter a random number seed (1..32767):  ");
        -: 3694:**        scanf("%d", &i);
        -: 3695:**        srand(i);
        -: 3696:*/
        -: 3697:
     3915: 3698:for (neurode = 0; neurode<MID_SIZE; neurode++)
        -: 3699:{
   121800: 3700:	for(i=0; i<IN_SIZE; i++)
        -: 3701:	{
        -: 3702:	        /* value=(double)abs_randwc(100000L); */
   121800: 3703:		value=(double)abs_randwc((int32)100000);
   121800: 3704:		value=value/(double)100000.0 - (double) 0.5;
   121800: 3705:		mid_wts[neurode][i] = value/2;
        -: 3706:	}
        -: 3707:}
     3480: 3708:for (neurode=0; neurode<OUT_SIZE; neurode++)
        -: 3709:{
    27840: 3710:	for(i=0; i<MID_SIZE; i++)
        -: 3711:	{
        -: 3712:	        /* value=(double)abs_randwc(100000L); */
    27840: 3713:		value=(double)abs_randwc((int32)100000);
    27840: 3714:		value=value/(double)10000.0 - (double) 0.5;
    27840: 3715:		out_wts[neurode][i] = value/2;
        -: 3716:	}
        -: 3717:}
        -: 3718:
      435: 3719:return;
        -: 3720:}
        -: 3721:
        -: 3722:
        -: 3723:/*********************
        -: 3724:** read_data_file() **
        -: 3725:**********************
        -: 3726:** Read in the input data file and store the patterns in
        -: 3727:** in_pats and out_pats.
        -: 3728:** The format for the data file is as follows:
        -: 3729:**
        -: 3730:** line#   data expected
        -: 3731:** -----   ------------------------------
        -: 3732:** 1               In-X-size,in-y-size,out-size
        -: 3733:** 2               number of patterns in file
        -: 3734:** 3               1st X row of 1st input pattern
        -: 3735:** 4..             following rows of 1st input pattern pattern
        -: 3736:**                 in-x+2  y-out pattern
        -: 3737:**                                 1st X row of 2nd pattern
        -: 3738:**                 etc.
        -: 3739:**
        -: 3740:** Each row of data is separated by commas or spaces.
        -: 3741:** The data is expected to be ascii text corresponding to
        -: 3742:** either a +1 or a 0.
        -: 3743:**
        -: 3744:** Sample input for a 1-pattern file (The comments to the
        -: 3745:** right may NOT be in the file unless more sophisticated
        -: 3746:** parsing of the input is done.):
        -: 3747:**
        -: 3748:** 5,7,8                      input is 5x7 grid, output is 8 bits
        -: 3749:** 1                          one pattern in file
        -: 3750:** 0,1,1,1,0                  beginning of pattern for "O"
        -: 3751:** 1,0,0,0,1
        -: 3752:** 1,0,0,0,1
        -: 3753:** 1,0,0,0,1
        -: 3754:** 1,0,0,0,1
        -: 3755:** 1,0,0,0,0
        -: 3756:** 0,1,1,1,0
        -: 3757:** 0,1,0,0,1,1,1,1            ASCII code for "O" -- 0100 1111
        -: 3758:**
        -: 3759:** Clearly, this simple scheme can be expanded or enhanced
        -: 3760:** any way you like.
        -: 3761:**
        -: 3762:** Returns -1 if any file error occurred, otherwise 0.
        -: 3763:**/
        1: 3764:static int read_data_file()
        -: 3765:{
        -: 3766:FILE *infile;
        -: 3767:
        -: 3768:int xinsize,yinsize,youtsize;
        -: 3769:int patt, element, i, row;
        -: 3770:int vals_read;
        -: 3771:int val1,val2,val3,val4,val5,val6,val7,val8;
        -: 3772:
        -: 3773:/* printf("\n Opening and retrieving data from file."); */
        -: 3774:
        1: 3775:infile = fopen(inpath, "r");
        1: 3776:if (infile == NULL)
        -: 3777:{
    #####: 3778:	printf("\n CPU:NNET--error in opening file!");
    #####: 3779:	return -1 ;
        -: 3780:}
        1: 3781:vals_read =fscanf(infile,"%d  %d  %d",&xinsize,&yinsize,&youtsize);
        1: 3782:if (vals_read != 3)
        -: 3783:{
    #####: 3784:	printf("\n CPU:NNET -- Should read 3 items in line one; did read %d",vals_read);
    #####: 3785:	return -1;
        -: 3786:}
        1: 3787:vals_read=fscanf(infile,"%d",&numpats);
        1: 3788:if (vals_read !=1)
        -: 3789:{
    #####: 3790:	printf("\n CPU:NNET -- Should read 1 item in line 2; did read %d",vals_read);
    #####: 3791:	return -1;
        -: 3792:}
        1: 3793:if (numpats > MAXPATS)
        1: 3794:	numpats = MAXPATS;
        -: 3795:
       10: 3796:for (patt=0; patt<numpats; patt++)
        -: 3797:{
        -: 3798:	element = 0;
       70: 3799:	for (row = 0; row<yinsize; row++)
        -: 3800:	{
       70: 3801:		vals_read = fscanf(infile,"%d  %d  %d  %d  %d",
        -: 3802:			&val1, &val2, &val3, &val4, &val5);
       70: 3803:		if (vals_read != 5)
        -: 3804:		{
    #####: 3805:			printf ("\n CPU:NNET -- failure in reading input!");
    #####: 3806:			return -1;
        -: 3807:		}
       70: 3808:		element=row*xinsize;
        -: 3809:
       70: 3810:		in_pats[patt][element] = (double) val1; element++;
       70: 3811:		in_pats[patt][element] = (double) val2; element++;
       70: 3812:		in_pats[patt][element] = (double) val3; element++;
       70: 3813:		in_pats[patt][element] = (double) val4; element++;
       70: 3814:		in_pats[patt][element] = (double) val5; element++;
        -: 3815:	}
      350: 3816:	for (i=0;i<IN_SIZE; i++)
        -: 3817:	{
      350: 3818:		if (in_pats[patt][i] >= 0.9)
      151: 3819:			in_pats[patt][i] = 0.9;
      350: 3820:		if (in_pats[patt][i] <= 0.1)
      199: 3821:			in_pats[patt][i] = 0.1;
        -: 3822:	}
       10: 3823:	element = 0;
       10: 3824:	vals_read = fscanf(infile,"%d  %d  %d  %d  %d  %d  %d  %d",
        -: 3825:		&val1, &val2, &val3, &val4, &val5, &val6, &val7, &val8);
        -: 3826:
       10: 3827:	out_pats[patt][element] = (double) val1; element++;
       10: 3828:	out_pats[patt][element] = (double) val2; element++;
       10: 3829:	out_pats[patt][element] = (double) val3; element++;
       10: 3830:	out_pats[patt][element] = (double) val4; element++;
       10: 3831:	out_pats[patt][element] = (double) val5; element++;
       10: 3832:	out_pats[patt][element] = (double) val6; element++;
       10: 3833:	out_pats[patt][element] = (double) val7; element++;
       10: 3834:	out_pats[patt][element] = (double) val8; element++;
        -: 3835:}
        -: 3836:
        -: 3837:/* printf("\n Closing the input file now. "); */
        -: 3838:
        1: 3839:fclose(infile);
        1: 3840:return(0);
        -: 3841:}
        -: 3842:
        -: 3843:/*********************
        -: 3844:** initialize_net() **
        -: 3845:**********************
        -: 3846:** Do all the initialization stuff before beginning
        -: 3847:*/
        -: 3848:/*
        -: 3849:static int initialize_net()
        -: 3850:{
        -: 3851:int err_code;
        -: 3852:
        -: 3853:randomize_wts();
        -: 3854:zero_changes();
        -: 3855:err_code = read_data_file();
        -: 3856:iteration_count = 1;
        -: 3857:return(err_code);
        -: 3858:}
        -: 3859:*/
        -: 3860:
        -: 3861:/**********************
        -: 3862:** display_mid_wts() **
        -: 3863:***********************
        -: 3864:** Display the weights on the middle layer neurodes
        -: 3865:** NOTE: This routine is not used in the benchmark
        -: 3866:**  test -- RG
        -: 3867:**/
        -: 3868:/* static void display_mid_wts()
        -: 3869:{
        -: 3870:int             neurode, weight, row, col;
        -: 3871:
        -: 3872:fprintf(outfile,"\n Weights of Middle Layer neurodes:");
        -: 3873:
        -: 3874:for (neurode=0; neurode<MID_SIZE; neurode++)
        -: 3875:{
        -: 3876:	fprintf(outfile,"\n  Mid Neurode # %d",neurode);
        -: 3877:	for (row=0; row<IN_Y_SIZE; row++)
        -: 3878:	{
        -: 3879:		fprintf(outfile,"\n ");
        -: 3880:		for (col=0; col<IN_X_SIZE; col++)
        -: 3881:		{
        -: 3882:			weight = IN_X_SIZE * row + col;
        -: 3883:			fprintf(outfile," %8.3f ", mid_wts[neurode][weight]);
        -: 3884:		}
        -: 3885:	}
        -: 3886:}
        -: 3887:return;
        -: 3888:}
        -: 3889:*/
        -: 3890:/**********************
        -: 3891:** display_out_wts() **
        -: 3892:***********************
        -: 3893:** Display the weights on the output layer neurodes
        -: 3894:** NOTE: This code is not used in the benchmark
        -: 3895:**  test -- RG
        -: 3896:*/
        -: 3897:/* void  display_out_wts()
        -: 3898:{
        -: 3899:int             neurode, weight;
        -: 3900:
        -: 3901:	fprintf(outfile,"\n Weights of Output Layer neurodes:");
        -: 3902:
        -: 3903:	for (neurode=0; neurode<OUT_SIZE; neurode++)
        -: 3904:	{
        -: 3905:		fprintf(outfile,"\n  Out Neurode # %d \n",neurode);
        -: 3906:		for (weight=0; weight<MID_SIZE; weight++)
        -: 3907:		{
        -: 3908:			fprintf(outfile," %8.3f ", out_wts[neurode][weight]);
        -: 3909:		}
        -: 3910:	}
        -: 3911:	return;
        -: 3912:}
        -: 3913:*/
        -: 3914:
        -: 3915:/***********************
        -: 3916:**  LU DECOMPOSITION  **
        -: 3917:** (Linear Equations) **
        -: 3918:************************
        -: 3919:** These routines come from "Numerical Recipes in Pascal".
        -: 3920:** Note that, as in the assignment algorithm, though we
        -: 3921:** separately define LUARRAYROWS and LUARRAYCOLS, the two
        -: 3922:** must be the same value (this routine depends on a square
        -: 3923:** matrix).
        -: 3924:*/
        -: 3925:
        -: 3926:/*********
        -: 3927:** DoLU **
        -: 3928:**********
        -: 3929:** Perform the LU decomposition benchmark.
        -: 3930:*/
    #####: 3931:void DoLU(void)
        -: 3932:{
        -: 3933:LUStruct *loclustruct;  /* Local pointer to global data */
        -: 3934:char *errorcontext;
        -: 3935:int systemerror;
        -: 3936:fardouble *a;
        -: 3937:fardouble *b;
        -: 3938:fardouble *abase;
        -: 3939:fardouble *bbase;
        -: 3940:LUdblptr ptra;
        -: 3941:int n;
        -: 3942:int i;
        -: 3943:ulong accumtime;
        -: 3944:double iterations;
        -: 3945:
        -: 3946:/*
        -: 3947:** Link to global data
        -: 3948:*/
    #####: 3949:loclustruct=&global_lustruct;
        -: 3950:
        -: 3951:/*
        -: 3952:** Set error context.
        -: 3953:*/
    #####: 3954:errorcontext="FPU:LU";
        -: 3955:
        -: 3956:/*
        -: 3957:** Our first step is to build a "solvable" problem.  This
        -: 3958:** will become the "seed" set that all others will be
        -: 3959:** derived from. (I.E., we'll simply copy these arrays
        -: 3960:** into the others.
        -: 3961:*/
    #####: 3962:a=(fardouble *)AllocateMemory(sizeof(double) * LUARRAYCOLS * LUARRAYROWS,
        -: 3963:		&systemerror);
    #####: 3964:b=(fardouble *)AllocateMemory(sizeof(double) * LUARRAYROWS,
        -: 3965:		&systemerror);
    #####: 3966:n=LUARRAYROWS;
        -: 3967:
        -: 3968:/*
        -: 3969:** We need to allocate a temp vector that is used by the LU
        -: 3970:** algorithm.  This removes the allocation routine from the
        -: 3971:** timing.
        -: 3972:*/
    #####: 3973:LUtempvv=(fardouble *)AllocateMemory(sizeof(double)*LUARRAYROWS,
        -: 3974:	&systemerror);
        -: 3975:
        -: 3976:/*
        -: 3977:** Build a problem to be solved.
        -: 3978:*/
    #####: 3979:ptra.ptrs.p=a;                  /* Gotta coerce linear array to 2D array */
    #####: 3980:build_problem(*ptra.ptrs.ap,n,b);
        -: 3981:
        -: 3982:/*
        -: 3983:** Now that we have a problem built, see if we need to do
        -: 3984:** auto-adjust.  If so, repeatedly call the DoLUIteration routine,
        -: 3985:** increasing the number of solutions per iteration as you go.
        -: 3986:*/
    #####: 3987:if(loclustruct->adjust==0)
        -: 3988:{
    #####: 3989:	loclustruct->numarrays=0;
    #####: 3990:	for(i=1;i<=MAXLUARRAYS;i++)
        -: 3991:	{
    #####: 3992:		abase=(fardouble *)AllocateMemory(sizeof(double) *
    #####: 3993:			LUARRAYCOLS*LUARRAYROWS*(i+1),&systemerror);
    #####: 3994:		if(systemerror)
    #####: 3995:		{       ReportError(errorcontext,systemerror);
    #####: 3996:			LUFreeMem(a,b,(fardouble *)NULL,(fardouble *)NULL);
    #####: 3997:			ErrorExit();
        -: 3998:		}
    #####: 3999:		bbase=(fardouble *)AllocateMemory(sizeof(double) *
        -: 4000:			LUARRAYROWS*(i+1),&systemerror);
    #####: 4001:		if(systemerror)
    #####: 4002:		{       ReportError(errorcontext,systemerror);
    #####: 4003:			LUFreeMem(a,b,abase,(fardouble *)NULL);
    #####: 4004:			ErrorExit();
        -: 4005:		}
    #####: 4006:		if(DoLUIteration(a,b,abase,bbase,i)>global_min_ticks)
    #####: 4007:		{       loclustruct->numarrays=i;
    #####: 4008:			break;
        -: 4009:		}
        -: 4010:		/*
        -: 4011:		** Not enough arrays...free them all and try again
        -: 4012:		*/
    #####: 4013:		FreeMemory((farvoid *)abase,&systemerror);
    #####: 4014:		FreeMemory((farvoid *)bbase,&systemerror);
        -: 4015:	}
        -: 4016:	/*
        -: 4017:	** Were we able to do it?
        -: 4018:	*/
    #####: 4019:	if(loclustruct->numarrays==0)
    #####: 4020:	{       printf("FPU:LU -- Array limit reached\n");
    #####: 4021:		LUFreeMem(a,b,abase,bbase);
    #####: 4022:		ErrorExit();
        -: 4023:	}
        -: 4024:}
        -: 4025:else
        -: 4026:{       /*
        -: 4027:	** Don't need to adjust -- just allocate the proper
        -: 4028:	** number of arrays and proceed.
        -: 4029:	*/
    #####: 4030:	abase=(fardouble *)AllocateMemory(sizeof(double) *
    #####: 4031:		LUARRAYCOLS*LUARRAYROWS*loclustruct->numarrays,
        -: 4032:		&systemerror);
    #####: 4033:	if(systemerror)
    #####: 4034:	{       ReportError(errorcontext,systemerror);
    #####: 4035:		LUFreeMem(a,b,(fardouble *)NULL,(fardouble *)NULL);
    #####: 4036:		ErrorExit();
        -: 4037:	}
    #####: 4038:	bbase=(fardouble *)AllocateMemory(sizeof(double) *
    #####: 4039:		LUARRAYROWS*loclustruct->numarrays,&systemerror);
    #####: 4040:	if(systemerror)
        -: 4041:	{
    #####: 4042:		ReportError(errorcontext,systemerror);
    #####: 4043:		LUFreeMem(a,b,abase,(fardouble *)NULL);
    #####: 4044:		ErrorExit();
        -: 4045:	}
        -: 4046:}
        -: 4047:/*
        -: 4048:** All's well if we get here.  Do the test.
        -: 4049:*/
    #####: 4050:accumtime=0L;
    #####: 4051:iterations=(double)0.0;
        -: 4052:
        -: 4053:do {
    #####: 4054:	accumtime+=DoLUIteration(a,b,abase,bbase,
        -: 4055:		loclustruct->numarrays);
    #####: 4056:	iterations+=(double)loclustruct->numarrays;
    #####: 4057:} while(TicksToSecs(accumtime)<loclustruct->request_secs);
        -: 4058:
        -: 4059:/*
        -: 4060:** Clean up, calculate results, and go home.  Be sure to
        -: 4061:** show that we don't have to rerun adjustment code.
        -: 4062:*/
    #####: 4063:loclustruct->iterspersec=iterations / TicksToFracSecs(accumtime);
        -: 4064:
    #####: 4065:if(loclustruct->adjust==0)
    #####: 4066:	loclustruct->adjust=1;
        -: 4067:
    #####: 4068:LUFreeMem(a,b,abase,bbase);
    #####: 4069:return;
        -: 4070:}
        -: 4071:
        -: 4072:/**************
        -: 4073:** LUFreeMem **
        -: 4074:***************
        -: 4075:** Release memory associated with LU benchmark.
        -: 4076:*/
    #####: 4077:static void LUFreeMem(fardouble *a, fardouble *b,
        -: 4078:			fardouble *abase,fardouble *bbase)
        -: 4079:{
        -: 4080:int systemerror;
        -: 4081:
    #####: 4082:FreeMemory((farvoid *)a,&systemerror);
    #####: 4083:FreeMemory((farvoid *)b,&systemerror);
    #####: 4084:FreeMemory((farvoid *)LUtempvv,&systemerror);
        -: 4085:
    #####: 4086:if(abase!=(fardouble *)NULL) FreeMemory((farvoid *)abase,&systemerror);
    #####: 4087:if(bbase!=(fardouble *)NULL) FreeMemory((farvoid *)bbase,&systemerror);
    #####: 4088:return;
        -: 4089:}
        -: 4090:
        -: 4091:/******************
        -: 4092:** DoLUIteration **
        -: 4093:*******************
        -: 4094:** Perform an iteration of the LU decomposition benchmark.
        -: 4095:** An iteration refers to the repeated solution of several
        -: 4096:** identical matrices.
        -: 4097:*/
    #####: 4098:static ulong DoLUIteration(fardouble *a,fardouble *b,
        -: 4099:		fardouble *abase, fardouble *bbase,
        -: 4100:		ulong numarrays)
        -: 4101:{
        -: 4102:fardouble *locabase;
        -: 4103:fardouble *locbbase;
        -: 4104:LUdblptr ptra;  /* For converting ptr to 2D array */
        -: 4105:ulong elapsed;
        -: 4106:ulong j,i;              /* Indexes */
        -: 4107:
        -: 4108:
        -: 4109:/*
        -: 4110:** Move the seed arrays (a & b) into the destination
        -: 4111:** arrays;
        -: 4112:*/
    #####: 4113:for(j=0;j<numarrays;j++)
    #####: 4114:{       locabase=abase+j*LUARRAYROWS*LUARRAYCOLS;
    #####: 4115:	locbbase=bbase+j*LUARRAYROWS;
    #####: 4116:	for(i=0;i<LUARRAYROWS*LUARRAYCOLS;i++)
    #####: 4117:		*(locabase+i)=*(a+i);
    #####: 4118:	for(i=0;i<LUARRAYROWS;i++)
    #####: 4119:		*(locbbase+i)=*(b+i);
        -: 4120:}
        -: 4121:
        -: 4122:/*
        -: 4123:** Do test...begin timing.
        -: 4124:*/
    #####: 4125:elapsed=StartStopwatch();
    #####: 4126:for(i=0;i<numarrays;i++)
    #####: 4127:{       locabase=abase+i*LUARRAYROWS*LUARRAYCOLS;
    #####: 4128:	locbbase=bbase+i*LUARRAYROWS;
    #####: 4129:	ptra.ptrs.p=locabase;
    #####: 4130:	lusolve(*ptra.ptrs.ap,LUARRAYROWS,locbbase);
        -: 4131:}
        -: 4132:
    #####: 4133:return(StopStopwatch(elapsed));
        -: 4134:}
        -: 4135:
        -: 4136:/******************
        -: 4137:** build_problem **
        -: 4138:*******************
        -: 4139:** Constructs a solvable set of linear equations.  It does this by
        -: 4140:** creating an identity matrix, then loading the solution vector
        -: 4141:** with random numbers.  After that, the identity matrix and
        -: 4142:** solution vector are randomly "scrambled".  Scrambling is
        -: 4143:** done by (a) randomly selecting a row and multiplying that
        -: 4144:** row by a random number and (b) adding one randomly-selected
        -: 4145:** row to another.
        -: 4146:*/
    #####: 4147:static void build_problem(double a[][LUARRAYCOLS],
        -: 4148:		int n,
        -: 4149:		double b[LUARRAYROWS])
        -: 4150:{
        -: 4151:long i,j,k,k1;  /* Indexes */
        -: 4152:double rcon;     /* Random constant */
        -: 4153:
        -: 4154:/*
        -: 4155:** Reset random number generator
        -: 4156:*/
        -: 4157:/* randnum(13L); */
    #####: 4158:randnum((int32)13);
        -: 4159:
        -: 4160:/*
        -: 4161:** Build an identity matrix.
        -: 4162:** We'll also use this as a chance to load the solution
        -: 4163:** vector.
        -: 4164:*/
    #####: 4165:for(i=0;i<n;i++)
        -: 4166:{       /* b[i]=(double)(abs_randwc(100L)+1L); */
    #####: 4167:	b[i]=(double)(abs_randwc((int32)100)+(int32)1);
    #####: 4168:	for(j=0;j<n;j++)
    #####: 4169:		if(i==j)
        -: 4170:		        /* a[i][j]=(double)(abs_randwc(1000L)+1L); */
    #####: 4171:			a[i][j]=(double)(abs_randwc((int32)1000)+(int32)1);
        -: 4172:		else
    #####: 4173:			a[i][j]=(double)0.0;
        -: 4174:}
        -: 4175:
        -: 4176:#ifdef DEBUG
        -: 4177:printf("Problem:\n");
        -: 4178:for(i=0;i<n;i++)
        -: 4179:{
        -: 4180:/*
        -: 4181:	for(j=0;j<n;j++)
        -: 4182:		printf("%6.2f ",a[i][j]);
        -: 4183:*/
        -: 4184:	printf("%.0f/%.0f=%.2f\t",b[i],a[i][i],b[i]/a[i][i]);
        -: 4185:/*
        -: 4186:        printf("\n");
        -: 4187:*/
        -: 4188:}
        -: 4189:#endif
        -: 4190:
        -: 4191:/*
        -: 4192:** Scramble.  Do this 8n times.  See comment above for
        -: 4193:** a description of the scrambling process.
        -: 4194:*/
        -: 4195:
    #####: 4196:for(i=0;i<8*n;i++)
        -: 4197:{
        -: 4198:	/*
        -: 4199:	** Pick a row and a random constant.  Multiply
        -: 4200:	** all elements in the row by the constant.
        -: 4201:	*/
        -: 4202: /*       k=abs_randwc((long)n);
        -: 4203:	rcon=(double)(abs_randwc(20L)+1L);
        -: 4204:	for(j=0;j<n;j++)
        -: 4205:		a[k][j]=a[k][j]*rcon;
        -: 4206:	b[k]=b[k]*rcon;
        -: 4207:*/
        -: 4208:	/*
        -: 4209:	** Pick two random rows and add second to
        -: 4210:	** first.  Note that we also occasionally multiply
        -: 4211:	** by minus 1 so that we get a subtraction operation.
        -: 4212:	*/
        -: 4213:        /* k=abs_randwc((long)n); */
        -: 4214:        /* k1=abs_randwc((long)n); */
    #####: 4215:	k=abs_randwc((int32)n);
    #####: 4216:	k1=abs_randwc((int32)n);
    #####: 4217:	if(k!=k1)
        -: 4218:	{
    #####: 4219:		if(k<k1) rcon=(double)1.0;
    #####: 4220:			else rcon=(double)-1.0;
    #####: 4221:		for(j=0;j<n;j++)
    #####: 4222:			a[k][j]+=a[k1][j]*rcon;;
    #####: 4223:		b[k]+=b[k1]*rcon;
        -: 4224:	}
        -: 4225:}
        -: 4226:
    #####: 4227:return;
        -: 4228:}
        -: 4229:
        -: 4230:
        -: 4231:/***********
        -: 4232:** ludcmp **
        -: 4233:************
        -: 4234:** From the procedure of the same name in "Numerical Recipes in Pascal",
        -: 4235:** by Press, Flannery, Tukolsky, and Vetterling.
        -: 4236:** Given an nxn matrix a[], this routine replaces it by the LU
        -: 4237:** decomposition of a rowwise permutation of itself.  a[] and n
        -: 4238:** are input.  a[] is output, modified as follows:
        -: 4239:**   --                       --
        -: 4240:**  |  b(1,1) b(1,2) b(1,3)...  |
        -: 4241:**  |  a(2,1) b(2,2) b(2,3)...  |
        -: 4242:**  |  a(3,1) a(3,2) b(3,3)...  |
        -: 4243:**  |  a(4,1) a(4,2) a(4,3)...  |
        -: 4244:**  |  ...                      |
        -: 4245:**   --                        --
        -: 4246:**
        -: 4247:** Where the b(i,j) elements form the upper triangular matrix of the
        -: 4248:** LU decomposition, and the a(i,j) elements form the lower triangular
        -: 4249:** elements.  The LU decomposition is calculated so that we don't
        -: 4250:** need to store the a(i,i) elements (which would have laid along the
        -: 4251:** diagonal and would have all been 1).
        -: 4252:**
        -: 4253:** indx[] is an output vector that records the row permutation
        -: 4254:** effected by the partial pivoting; d is output as +/-1 depending
        -: 4255:** on whether the number of row interchanges was even or odd,
        -: 4256:** respectively.
        -: 4257:** Returns 0 if matrix singular, else returns 1.
        -: 4258:*/
    #####: 4259:static int ludcmp(double a[][LUARRAYCOLS],
        -: 4260:		int n,
        -: 4261:		int indx[],
        -: 4262:		int *d)
        -: 4263:{
        -: 4264:
        -: 4265:double big;     /* Holds largest element value */
        -: 4266:double sum;
        -: 4267:double dum;     /* Holds dummy value */
        -: 4268:int i,j,k;      /* Indexes */
    #####: 4269:int imax=0;     /* Holds max index value */
        -: 4270:double tiny;    /* A really small number */
        -: 4271:
    #####: 4272:tiny=(double)1.0e-20;
        -: 4273:
    #####: 4274:*d=1;           /* No interchanges yet */
        -: 4275:
    #####: 4276:for(i=0;i<n;i++)
        -: 4277:{       big=(double)0.0;
    #####: 4278:	for(j=0;j<n;j++)
    #####: 4279:		if((double)fabs(a[i][j]) > big)
    #####: 4280:			big=fabs(a[i][j]);
        -: 4281:	/* Bail out on singular matrix */
    #####: 4282:	if(big==(double)0.0) return(0);
    #####: 4283:	LUtempvv[i]=1.0/big;
        -: 4284:}
        -: 4285:
        -: 4286:/*
        -: 4287:** Crout's algorithm...loop over columns.
        -: 4288:*/
    #####: 4289:for(j=0;j<n;j++)
    #####: 4290:{       if(j!=0)
    #####: 4291:		for(i=0;i<j;i++)
    #####: 4292:		{       sum=a[i][j];
    #####: 4293:			if(i!=0)
    #####: 4294:				for(k=0;k<i;k++)
    #####: 4295:					sum-=(a[i][k]*a[k][j]);
    #####: 4296:			a[i][j]=sum;
        -: 4297:		}
        -: 4298:	big=(double)0.0;
    #####: 4299:	for(i=j;i<n;i++)
    #####: 4300:	{       sum=a[i][j];
    #####: 4301:		if(j!=0)
    #####: 4302:			for(k=0;k<j;k++)
    #####: 4303:				sum-=a[i][k]*a[k][j];
    #####: 4304:		a[i][j]=sum;
    #####: 4305:		dum=LUtempvv[i]*fabs(sum);
    #####: 4306:		if(dum>=big)
    #####: 4307:		{       big=dum;
    #####: 4308:			imax=i;
        -: 4309:		}
        -: 4310:	}
    #####: 4311:	if(j!=imax)             /* Interchange rows if necessary */
    #####: 4312:	{       for(k=0;k<n;k++)
    #####: 4313:		{       dum=a[imax][k];
    #####: 4314:			a[imax][k]=a[j][k];
    #####: 4315:			a[j][k]=dum;
        -: 4316:		}
    #####: 4317:		*d=-*d;         /* Change parity of d */
    #####: 4318:		dum=LUtempvv[imax];
    #####: 4319:		LUtempvv[imax]=LUtempvv[j]; /* Don't forget scale factor */
    #####: 4320:		LUtempvv[j]=dum;
        -: 4321:	}
    #####: 4322:	indx[j]=imax;
        -: 4323:	/*
        -: 4324:	** If the pivot element is zero, the matrix is singular
        -: 4325:	** (at least as far as the precision of the machine
        -: 4326:	** is concerned.)  We'll take the original author's
        -: 4327:	** recommendation and replace 0.0 with "tiny".
        -: 4328:	*/
    #####: 4329:	if(a[j][j]==(double)0.0)
    #####: 4330:		a[j][j]=tiny;
        -: 4331:
    #####: 4332:	if(j!=(n-1))
    #####: 4333:	{       dum=1.0/a[j][j];
    #####: 4334:		for(i=j+1;i<n;i++)
    #####: 4335:			a[i][j]=a[i][j]*dum;
        -: 4336:	}
        -: 4337:}
        -: 4338:
        -: 4339:return(1);
        -: 4340:}
        -: 4341:
        -: 4342:/***********
        -: 4343:** lubksb **
        -: 4344:************
        -: 4345:** Also from "Numerical Recipes in Pascal".
        -: 4346:** This routine solves the set of n linear equations A X = B.
        -: 4347:** Here, a[][] is input, not as the matrix A, but as its
        -: 4348:** LU decomposition, created by the routine ludcmp().
        -: 4349:** Indx[] is input as the permutation vector returned by ludcmp().
        -: 4350:**  b[] is input as the right-hand side an returns the
        -: 4351:** solution vector X.
        -: 4352:** a[], n, and indx are not modified by this routine and
        -: 4353:** can be left in place for different values of b[].
        -: 4354:** This routine takes into account the possibility that b will
        -: 4355:** begin with many zero elements, so it is efficient for use in
        -: 4356:** matrix inversion.
        -: 4357:*/
    #####: 4358:static void lubksb( double a[][LUARRAYCOLS],
        -: 4359:		int n,
        -: 4360:		int indx[LUARRAYROWS],
        -: 4361:		double b[LUARRAYROWS])
        -: 4362:{
        -: 4363:
        -: 4364:int i,j;        /* Indexes */
        -: 4365:int ip;         /* "pointer" into indx */
        -: 4366:int ii;
        -: 4367:double sum;
        -: 4368:
        -: 4369:/*
        -: 4370:** When ii is set to a positive value, it will become
        -: 4371:** the index of the first nonvanishing element of b[].
        -: 4372:** We now do the forward substitution. The only wrinkle
        -: 4373:** is to unscramble the permutation as we go.
        -: 4374:*/
    #####: 4375:ii=-1;
    #####: 4376:for(i=0;i<n;i++)
    #####: 4377:{       ip=indx[i];
    #####: 4378:	sum=b[ip];
    #####: 4379:	b[ip]=b[i];
    #####: 4380:	if(ii!=-1)
    #####: 4381:		for(j=ii;j<i;j++)
    #####: 4382:			sum=sum-a[i][j]*b[j];
        -: 4383:	else
        -: 4384:		/*
        -: 4385:		** If a nonzero element is encountered, we have
        -: 4386:		** to do the sums in the loop above.
        -: 4387:		*/
    #####: 4388:		if(sum!=(double)0.0)
    #####: 4389:			ii=i;
    #####: 4390:	b[i]=sum;
        -: 4391:}
        -: 4392:/*
        -: 4393:** Do backsubstitution
        -: 4394:*/
    #####: 4395:for(i=(n-1);i>=0;i--)
        -: 4396:{
    #####: 4397:	sum=b[i];
    #####: 4398:	if(i!=(n-1))
    #####: 4399:		for(j=(i+1);j<n;j++)
    #####: 4400:			sum=sum-a[i][j]*b[j];
    #####: 4401:	b[i]=sum/a[i][i];
        -: 4402:}
    #####: 4403:return;
        -: 4404:}
        -: 4405:
        -: 4406:/************
        -: 4407:** lusolve **
        -: 4408:*************
        -: 4409:** Solve a linear set of equations: A x = b
        -: 4410:** Original matrix A will be destroyed by this operation.
        -: 4411:** Returns 0 if matrix is singular, 1 otherwise.
        -: 4412:*/
    #####: 4413:static int lusolve(double a[][LUARRAYCOLS],
        -: 4414:		int n,
        -: 4415:		double b[LUARRAYROWS])
        -: 4416:{
        -: 4417:int indx[LUARRAYROWS];
        -: 4418:int d;
        -: 4419:#ifdef DEBUG
        -: 4420:int i,j;
        -: 4421:#endif
        -: 4422:
    #####: 4423:if(ludcmp(a,n,indx,&d)==0) return(0);
        -: 4424:
        -: 4425:/* Matrix not singular -- proceed */
    #####: 4426:lubksb(a,n,indx,b);
        -: 4427:
        -: 4428:#ifdef DEBUG
        -: 4429:printf("Solution:\n");
        -: 4430:for(i=0;i<n;i++)
        -: 4431:{
        -: 4432:  for(j=0;j<n;j++){
        -: 4433:  /*
        -: 4434:    printf("%6.2f ",a[i][j]);
        -: 4435:  */
        -: 4436:  }
        -: 4437:  printf("%6.2f\t",b[i]);
        -: 4438:  /*
        -: 4439:    printf("\n");
        -: 4440:  */
        -: 4441:}
        -: 4442:printf("\n");
        -: 4443:#endif
        -: 4444:
    #####: 4445:return(1);
        -: 4446:}
